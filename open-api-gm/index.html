<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>VEINBREAKER</title>

  <style>
    :root {
      --bg: #0b0d0f;
      --fg: #d6d6d6;
      --dim: #8a8a8a;
      --accent: #9e2b25;
      --line: #1e2226;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 14px;
    }

    header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      color: var(--dim);
      letter-spacing: 2px;
    }

    #log {
      padding: 16px;
      max-width: 900px;
      margin: 0 auto;
      min-height: 60vh;
    }

    .entry {
      margin-bottom: 12px;
      white-space: pre-wrap;
    }

    .scene {
      color: var(--dim);
    }

    .narration {
      color: var(--fg);
    }

    .loot {
      color: var(--accent);
    }

    .system {
      color: var(--dim);
      font-style: italic;
    }

footer {
  border-top: 1px solid var(--line);
  padding: 12px 16px;
  flex-shrink: 0;
  background: var(--bg);
}

    .combat-mode #narration-wrapper::after {
      background:
        radial-gradient(circle at 40% 30%, rgba(180, 0, 0, 0.25), transparent 60%),
        radial-gradient(circle at 60% 70%, rgba(120, 0, 0, 0.2), transparent 65%);
    }

    .choice {
      display: block;
      background: none;
      border: none;
      color: var(--fg);
      text-align: left;
      padding: 6px 0;
      cursor: pointer;
      font-family: inherit;
    }

    .choice:hover {
      color: var(--accent);
    }

    .prompt {
      color: var(--dim);
      margin-bottom: 8px;
    }

  #layout {
    display: flex;
    height: calc(100vh - 48px);
  }
/* ===== CHAIN OVERLAY ===== */
#chain-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  backdrop-filter: blur(3px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#chain-overlay.hidden {
  display: none;
}

.chain-active #narration-wrapper {
  opacity: 0.28;
  filter: blur(2px);
}

.chain-active #log,
.chain-active footer {
  opacity: 0.55;
}

.chain-modal {
  width: min(1100px, 92vw);
  max-height: 86vh;
  overflow: auto;
  background: #0d0d0d;
  border: 1px solid var(--accent);
  box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.2);
  padding: 14px 14px 16px;
}

.chain-title {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--line);
  padding-bottom: 10px;
  margin-bottom: 12px;
}

.chain-h {
  letter-spacing: 3px;
  color: var(--fg);
  font-size: 12px;
}

.chain-sub {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
}

.chain-close {
  background: none;
  border: 1px solid var(--line);
  color: var(--dim);
  cursor: pointer;
  font-family: inherit;
  padding: 6px 10px;
}

.chain-close:hover {
  border-color: var(--accent);
  color: var(--fg);
}

.chain-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.ability-column h3 {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--dim);
  margin: 0 0 8px;
}

.ability-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.ability-card {
  border: 1px solid var(--line);
  background: #101113;
  padding: 10px 10px 9px;
  cursor: pointer;
  transition: border-color 0.12s ease, transform 0.12s ease;
}

.ability-card:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.ability-card.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none;
}

.ability-card .row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.ability-card .name {
  color: var(--fg);
  font-size: 13px;
}

.ability-card .meta {
  color: var(--dim);
  font-size: 12px;
}

.ability-card .desc {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
  line-height: 1.35;
}

.chain-preview {
  border-top: 1px solid var(--line);
  margin-top: 14px;
  padding-top: 12px;
}

#chain-slots {
  display: flex;
  gap: 10px;
  margin: 10px 0 12px;
  flex-wrap: wrap;
}

.chain-slot {
  width: 150px;
  height: 54px;
  border: 1px dashed var(--line);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--dim);
}

.chain-slot.filled {
  border-style: solid;
  background: rgba(158, 43, 37, 0.12);
  color: var(--fg);
  cursor: pointer;
}

.chain-actions {
  display: flex;
  gap: 10px;
}

#chain-commit {
  border: 1px solid var(--accent);
  background: rgba(158, 43, 37, 0.15);
  color: var(--fg);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

#chain-commit:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.secondary {
  border: 1px solid var(--line);
  background: none;
  color: var(--dim);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

.secondary:hover {
  border-color: var(--accent);
  color: var(--fg);
}

  .chain-hint {
    margin-top: 10px;
    color: var(--dim);
    font-size: 12px;
  }

  /* ===== ABILITIES PANEL ===== */

  #abilities-panel {
    margin-top: 16px;
    border-top: 1px solid var(--line);
    padding-top: 10px;
  }

  #abilities-panel .panel-title {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--dim);
    margin-bottom: 8px;
  }

  #abilities-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .ability-row {
    border: 1px solid var(--line);
    padding: 6px 8px;
    background: #101113;
    font-size: 12px;
  }

  .ability-row.cooldown {
    opacity: 0.45;
  }

  .ability-row .top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }

  .ability-row .name {
    color: var(--fg);
  }

  .ability-row .meta {
    color: var(--dim);
    font-size: 11px;
  }

  .ability-row .tags {
    margin-top: 4px;
    font-size: 10px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

@keyframes chain-heartbeat {
  0% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
  35% {
    box-shadow:
      0 0 16px 4px rgba(158, 43, 37, 0.35),
      inset 0 0 10px 2px rgba(158, 43, 37, 0.28);
  }
  70% {
    box-shadow:
      0 0 10px 3px rgba(158, 43, 37, 0.22),
      inset 0 0 6px 2px rgba(158, 43, 37, 0.18);
  }
  100% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
}

  .chain-pulse .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
  }
  /* Alternate trigger for visibility-based pulse */
  .chain-pulse-active .chain-modal {
    animation: chain-heartbeat 1.4s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.65);
  }
  /* Keep the pulse active whenever the overlay is visible, even if chain-pulse isn't toggled */
  #chain-overlay:not(.hidden) .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.55);
  }

@keyframes chain-reject-shake {
  0%   { transform: translateX(0); }
  15%  { transform: translateX(-6px); }
  30%  { transform: translateX(6px); }
  45%  { transform: translateX(-4px); }
  60%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

@keyframes chain-reject-flash {
  0%   { background-color: rgba(180, 0, 0, 0.35); }
  100% { background-color: transparent; }
}

.chain-reject .chain-modal {
  animation: chain-reject-shake 0.35s ease;
}

.chain-reject::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(180, 0, 0, 0.25);
  animation: chain-reject-flash 0.25s ease-out;
  pointer-events: none;
  z-index: 1001;
}

  #character-panel {
    width: 180px;
    padding: 16px 12px;
    border-right: 1px solid var(--line);
      color: var(--dim);
    }

    .vein-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .vein-node {
      width: 64px;
      height: 64px;
      border: 1px solid var(--accent);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle, rgba(158, 43, 37, 0.15), transparent 70%);
    }

    .vein-node .label {
      font-size: 10px;
      letter-spacing: 1px;
      color: var(--dim);
    }

    .vein-node .value {
      font-size: 18px;
      color: var(--fg);
    }

    .stats {
      border-top: 1px solid var(--line);
      padding-top: 12px;
      font-size: 12px;
    }

  .stats div {
    display: flex;
    justify-content: space-between;
    margin: 4px 0;
  }

  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-width: 0;
  }

  #main-scroll {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 12px;
  }

  /* ===== ENEMY CARD ===== */

  .monster-card {
    border-bottom: 1px solid var(--line);
    padding: 10px 14px;
    background: linear-gradient(180deg, rgba(16, 17, 19, 0.95), rgba(12, 12, 12, 0.9));
  }

  .monster-card.hidden {
    display: none;
  }

  .monster-top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 8px;
  }

  .monster-name {
    color: var(--fg);
    letter-spacing: 2px;
    font-size: 12px;
    text-transform: uppercase;
  }

  .monster-meta {
    color: var(--dim);
    font-size: 11px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .monster-meters {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .meter-row {
    display: grid;
    grid-template-columns: 34px 1fr 56px;
    gap: 8px;
    align-items: center;
    font-size: 11px;
    color: var(--dim);
  }

  .meter-label {
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .meter-value {
    text-align: right;
    color: var(--fg);
    font-variant-numeric: tabular-nums;
  }

  .meter-bar {
    height: 10px;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 2px;
    overflow: hidden;
  }

  .meter-fill {
    height: 100%;
    width: 0%;
    transition: width 0.2s ease;
    background: rgba(158, 43, 37, 0.75);
  }

  .meter-bar.hp .meter-fill { background: rgba(158, 43, 37, 0.85); }
  .meter-bar.heat .meter-fill { background: linear-gradient(90deg, #ff9f1c, #ff3d00); }
  .meter-bar.mom .meter-fill { background: linear-gradient(90deg, #4f7cff, #79a6ff); }

  #combat-log-panel {
    width: 260px;
    border-left: 1px solid var(--line);
    padding: 12px;
    font-size: 12px;
    color: var(--dim);
    background: #0b0b0b;
    position: relative;
  }

  #combat-log-header {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--fg);
    margin-bottom: 8px;
    opacity: 0.8;
    display: flex;
    align-items: center;
    cursor: pointer;
  }

  #signal-dot {
    width: 8px;
    height: 8px;
    background: rgba(158, 43, 37, 0.9);
    border-radius: 50%;
    margin-left: 8px;
    animation: signal-pulse 1.6s ease-in-out infinite;
  }

  #signal-dot.hidden {
    display: none;
  }

  @keyframes signal-pulse {
    0% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
    50% { box-shadow: 0 0 8px rgba(158,43,37,0.6); }
    100% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
  }

  #combat-log {
    max-height: calc(100vh - 60px);
    overflow-y: auto;
    padding-right: 6px;
  }

  .log-entry {
    margin-bottom: 6px;
    line-height: 1.4;
  }

  .log-entry.attack { color: #c9c9c9; }
  .log-entry.damage { color: #e07070; }
  .log-entry.block  { color: #7fa6ff; }
  .log-entry.system { color: #888; }
  .log-entry.interrupt { color: #ff8484; }
  .log-entry.roll { color: #e07070; font-weight: 600; }

  #main-scroll::-webkit-scrollbar,
  #combat-log::-webkit-scrollbar {
    width: 6px;
  }

  #main-scroll::-webkit-scrollbar-track,
  #combat-log::-webkit-scrollbar-track {
    background: transparent;
  }

  #main-scroll::-webkit-scrollbar-thumb,
  #combat-log::-webkit-scrollbar-thumb {
    background-color: rgba(158, 43, 37, 0.35);
    border-radius: 6px;
  }

  #main-scroll::-webkit-scrollbar-thumb:hover,
  #combat-log::-webkit-scrollbar-thumb:hover {
    background-color: rgba(158, 43, 37, 0.6);
  }

  .signal-drawer {
    position: absolute;
    right: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: #0b0c0e;
    border-left: 1px solid var(--line);
    z-index: 20;
  }

  .signal-drawer.hidden {
    display: none;
  }

  .signal-drawer-header {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    display: flex;
    justify-content: space-between;
    letter-spacing: 2px;
    font-size: 11px;
    color: var(--fg);
  }

  .signal {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    background: rgba(158, 43, 37, 0.12);
    color: var(--fg);
  }

  /* Interrupt flash */
@keyframes interrupt-flash {
  0%   { background-color: rgba(180, 0, 0, 0.15); }
  50%  { background-color: rgba(180, 0, 0, 0.35); }
  100% { background-color: transparent; }
}

.interrupt-flash {
  animation: interrupt-flash 0.18s ease-out;
}

/* ===== INTERRUPT SLIDE-UP ===== */
#interrupt-window {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: 42vh;
  background: linear-gradient(to top, #0b0c0e, #0f1114);
  border-top: 2px solid var(--accent);
  z-index: 1100;
  transform: translateY(100%);
  transition: transform 0.22s ease-out;
}

#interrupt-window.active {
  transform: translateY(0);
}

#interrupt-window.hidden {
  display: none;
}

.interrupt-header {
  display: flex;
  justify-content: space-between;
  padding: 10px 14px;
  letter-spacing: 2px;
  font-size: 11px;
  color: var(--fg);
  border-bottom: 1px solid var(--line);
}

.interrupt-list {
  padding: 12px;
  display: flex;
  gap: 10px;
  overflow-x: auto;
}

.interrupt-list .ability-card {
  min-width: 220px;
  border-color: rgba(158, 43, 37, 0.6);
}

.interrupt-footer {
  padding: 10px;
  border-top: 1px solid var(--line);
  text-align: right;
}

.interrupt-skip {
  background: none;
  border: 1px solid var(--line);
  color: var(--dim);
  padding: 6px 12px;
  cursor: pointer;
}

.interrupt-skip:hover {
  border-color: var(--accent);
  color: var(--fg);
}

/* ===== INTERRUPTED OVERLAY ===== */
.interrupt-overlay {
  position: fixed;
  inset: 0;
  /* Keep below the interrupt chooser so it never blocks selection */
  z-index: 1050;
  background: radial-gradient(
    circle at center,
    rgba(180, 30, 30, 0.25),
    rgba(0, 0, 0, 0.85)
  );
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  opacity: 0;
  transform: scale(1.02);
  transition: opacity 0.15s ease-out, transform 0.15s ease-out;
}

.interrupt-overlay.active {
  opacity: 1;
  transform: scale(1);
}

.interrupt-overlay.hidden {
  display: none;
}

  .interrupt-text {
    font-family: inherit;
    font-size: clamp(48px, 8vw, 96px);
    letter-spacing: 0.3em;
    color: #e54b4b;
  text-shadow:
    0 0 8px rgba(229, 75, 75, 0.6),
    0 0 24px rgba(229, 75, 75, 0.4),
    0 0 48px rgba(229, 75, 75, 0.25);
  animation: interrupt-smear 0.18s steps(2) 3;
}

  @keyframes interrupt-smear {
    0%   { transform: translateX(0); }
    33%  { transform: translateX(-6px); }
    66%  { transform: translateX(6px); }
    100% { transform: translateX(0); }
  }

  /* ===== LOOT OVERLAY ===== */

  .loot-overlay {
    position: fixed;
    inset: 0;
    z-index: 1600;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.78);
    opacity: 0;
    transition: opacity 0.18s ease-out;
  }

  .loot-overlay.active {
    opacity: 1;
  }

  .loot-overlay.hidden {
    display: none;
  }

  .loot-modal {
    width: min(720px, calc(100vw - 32px));
    max-height: min(72vh, 720px);
    display: flex;
    flex-direction: column;
    border: 1px solid var(--line);
    background: linear-gradient(180deg, #0f1114, #0b0c0e);
    box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.18), 0 18px 60px rgba(0, 0, 0, 0.55);
  }

  .loot-title {
    padding: 12px 14px;
    border-bottom: 1px solid var(--line);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .loot-h {
    letter-spacing: 3px;
    font-size: 12px;
    color: var(--fg);
  }

  .loot-sub {
    font-size: 12px;
    color: var(--dim);
  }

  .loot-items {
    padding: 12px 14px;
    overflow: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .loot-item {
    border: 1px solid var(--line);
    background: #101113;
    padding: 10px 10px;
  }

  .loot-item-top {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: baseline;
  }

  .loot-item-name {
    color: var(--fg);
    font-size: 13px;
  }

  .loot-item-rarity {
    color: var(--dim);
    font-size: 11px;
    letter-spacing: 2px;
  }

  .loot-item-desc {
    margin-top: 6px;
    color: var(--dim);
    font-size: 12px;
    line-height: 1.35;
  }

  .loot-actions {
    padding: 12px 14px;
    border-top: 1px solid var(--line);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
  }

/* ===== COMBAT RESULT OVERLAY ===== */
.result-overlay {
  position: fixed;
  inset: 0;
  z-index: 2100;
  background: radial-gradient(circle at center, rgba(30, 180, 80, 0.18), rgba(0, 0, 0, 0.88));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 18px;
  opacity: 0;
  transform: scale(1.02);
  transition: opacity 0.15s ease-out, transform 0.15s ease-out;
}

.result-overlay.defeat {
  background: radial-gradient(circle at center, rgba(180, 30, 30, 0.18), rgba(0, 0, 0, 0.88));
}

.result-overlay.active {
  opacity: 1;
  transform: scale(1);
}

.result-overlay.hidden {
  display: none;
}

.result-text {
  font-family: inherit;
  font-size: clamp(48px, 8vw, 96px);
  letter-spacing: 0.22em;
  color: var(--fg);
  text-shadow:
    0 0 8px rgba(255, 255, 255, 0.15),
    0 0 24px rgba(255, 255, 255, 0.08);
}

.result-overlay.defeat .result-text {
  color: #e54b4b;
  text-shadow:
    0 0 8px rgba(229, 75, 75, 0.6),
    0 0 24px rgba(229, 75, 75, 0.35);
}

.result-continue {
  background: none;
  border: 1px solid var(--line);
  color: var(--fg);
  padding: 10px 18px;
  letter-spacing: 2px;
  cursor: pointer;
}

.result-continue:hover {
  border-color: var(--accent);
}

/* ===== HEAT METER ===== */
.heat-container {
  margin-top: 10px;
}

.heat-label {
  font-size: 10px;
  letter-spacing: 2px;
  color: #ffb347;
  margin-bottom: 4px;
}

.heat-bar {
  position: relative;
  height: 10px;
  background: #1a0f08;
  border: 1px solid #3a1d0f;
  overflow: hidden;
}

.heat-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #ff9f1c, #ff6f00, #ff3d00);
  box-shadow:
    0 0 6px rgba(255, 140, 0, 0.6),
    0 0 12px rgba(255, 90, 0, 0.4);
  transition: width 0.25s ease, box-shadow 0.25s ease;
}

.heat-container.high .heat-fill {
  animation: heat-pulse 0.8s infinite alternate;
}

@keyframes heat-pulse {
  from { box-shadow: 0 0 10px rgba(255, 100, 0, 0.8); }
  to   { box-shadow: 0 0 18px rgba(255, 50, 0, 1); }
}

.heat-value {
  font-size: 11px;
  color: #ffcc80;
  margin-top: 4px;
  text-align: right;
}

/* ===== MOMENTUM ===== */
.momentum-panel {
  margin-top: 10px;
}

.momentum-header {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  letter-spacing: 0.15em;
  color: #9bb3c9;
}

.momentum-bar {
  position: relative;
  height: 10px;
  background: #14181c;
  border-radius: 2px;
  overflow: hidden;
}

#momentum-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #4f7cff, #79a6ff);
  box-shadow: 0 0 6px rgba(79, 124, 255, 0.4);
  transition: width 0.25s ease-out;
}

.momentum-shock #momentum-fill {
  animation: momentum-shock 0.25s ease-out;
}

@keyframes momentum-shock {
  0%   { filter: brightness(1.6); }
  100% { filter: brightness(1); }
}

/* ===== BALANCE ===== */
.balance-panel {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.balance-panel.hidden {
  display: none;
}

.balance-label {
  font-size: 10px;
  letter-spacing: 0.2em;
  color: #b0b8c2;
}

.balance-pips {
  display: flex;
  gap: 4px;
}

.balance-pip {
  width: 8px;
  height: 8px;
  background: #3a3f45;
  border-radius: 1px;
}

.balance-pip.active {
  background: #9bb3c9;
}

.balance-pip.negative {
  background: #ff6a6a;
}

.balance-wobble {
  animation: balance-wobble 0.2s ease-out;
}

@keyframes balance-wobble {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  100% { transform: translateX(0); }
}

  /* ===== Narration Container ===== */

    #narration-wrapper {
      position: relative;
      overflow: hidden;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }

    #narration {
      transition: opacity 0.4s ease, filter 0.4s ease;
    }

    /* ===== Fade / Smear States ===== */

    .fade-out {
      opacity: 0;
      filter: blur(6px) contrast(120%) saturate(120%);
    }

    .fade-in {
      opacity: 1;
      filter: blur(0);
    }

    /* ===== Vein Smear Overlay ===== */

    #narration-wrapper::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 30% 40%,
          rgba(140, 0, 0, 0.15),
          transparent 60%),
        radial-gradient(circle at 70% 60%,
          rgba(90, 0, 0, 0.12),
          transparent 65%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .smear-active::after {
      opacity: 1;
    }
  </style>
</head>

<body>

  <header>
    VEINBREAKER
  </header>

<div id="layout">
  <aside id="character-panel">
    <div class="vein-column">
      <div class="vein-node" id="hp-node">
        <span class="label">HP</span>
        <span class="value" id="char-hp">–</span>
      </div>

      <div class="vein-node" id="rp-node">
        <span class="label">RP</span>
        <span class="value" id="char-rp">–</span>
      </div>

      <div class="vein-node" id="veinscore-node">
        <span class="label">VEIN</span>
        <span class="value" id="char-veinscore">–</span>
      </div>
    </div>

    <div class="stats">
      <div>POW <span id="stat-str">–</span></div>
      <div>AGI <span id="stat-dex">–</span></div>
      <div>MND <span id="stat-int">–</span></div>
      <div>SPR <span id="stat-wil">–</span></div>
    </div>

    <!-- HEAT METER -->
    <div id="heat-container" class="heat-container">
      <div class="heat-label">HEAT</div>
      <div class="heat-bar">
        <div id="heat-fill" class="heat-fill"></div>
      </div>
      <div id="heat-value" class="heat-value">0</div>
    </div>

    <!-- MOMENTUM -->
    <div id="momentum-panel" class="momentum-panel">
      <div class="momentum-header">
        <span>MOMENTUM</span>
        <span id="momentum-value">0</span>
      </div>
      <div class="momentum-bar">
        <div id="momentum-fill"></div>
      </div>
    </div>

    <section id="abilities-panel">
      <div class="panel-title">ABILITIES</div>
      <div id="abilities-list"></div>
    </section>
  </aside>

  <main id="main">
    <!-- Enemy HUD card (stays visible during combat; not part of narration/log clearing) -->
    <section id="enemy-card" class="monster-card hidden" aria-live="polite">
      <div class="monster-top">
        <div class="monster-name" id="enemy-name">ENEMY</div>
        <div class="monster-meta" id="enemy-meta"></div>
      </div>

      <div class="monster-meters">
        <div class="meter-row">
          <div class="meter-label">HP</div>
          <div class="meter-bar hp"><div id="enemy-hp-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-hp-text">—</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">HEAT</div>
          <div class="meter-bar heat"><div id="enemy-heat-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-heat-text">0</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">MOM</div>
          <div class="meter-bar mom"><div id="enemy-mom-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-mom-text">0</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">BAL</div>
          <div class="meter-bar bal"><div id="enemy-bal-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-bal-text">0</div>
        </div>
      </div>
    </section>

    <div id="main-scroll">
      <div id="narration-wrapper">
        <div id="narration"></div>
      </div>
      <div id="log"></div>
    </div>

    <footer id="choices"></footer>
  </main>

  <aside id="combat-log-panel">
    <div id="combat-log-header" onclick="openSignals()">
      <span>COMBAT LOG</span>
      <span id="signal-dot" class="signal-dot hidden"></span>
    </div>
    <div id="signal-drawer" class="signal-drawer hidden">
      <div class="signal-drawer-header">
        SIGNALS
        <button onclick="closeSignals()">✕</button>
      </div>
      <div id="signal-list"></div>
    </div>
    <div id="combat-log"></div>
  </aside>
</div>

<!-- CHAIN OVERLAY (hidden until declare_chain event) -->
<div id="chain-overlay" class="hidden" aria-hidden="true">
  <div class="chain-modal">
    <div class="chain-title">
      <div class="chain-title-left">
        <div class="chain-h">DECLARE CHAIN</div>
        <div class="chain-sub" id="chain-sub">Select up to <span id="chain-max">6</span> links.</div>
      </div>
      <button class="chain-close" onclick="closeChainBuilder()">X</button>
    </div>

    <div class="chain-columns">
      <div class="ability-column">
        <h3>ATTACK</h3>
        <div id="attack-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>DEFENSE</h3>
        <div id="defense-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>UTILITY</h3>
        <div id="utility-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>MOVEMENT</h3>
        <div id="movement-abilities" class="ability-list"></div>
      </div>
    </div>

    <div class="chain-preview">
      <h3>CHAIN</h3>
      <div id="chain-slots"></div>

      <!-- BALANCE -->
      <div id="balance-panel" class="balance-panel hidden">
        <span class="balance-label">BALANCE</span>
        <div id="balance-pips" class="balance-pips"></div>
      </div>

      <div class="chain-actions">
        <button id="chain-commit" onclick="submitChain()">COMMIT CHAIN</button>
        <button class="secondary" onclick="clearChain()">CLEAR</button>
      </div>

      <div class="chain-hint" id="chain-hint">Tip: click a filled slot to remove it.</div>
    </div>
  </div>
</div>

<!-- INTERRUPT WINDOW -->
<div id="interrupt-window" class="interrupt hidden">
  <div class="interrupt-header">
    <span>INTERRUPT WINDOW</span>
    <span class="interrupt-timer" id="interrupt-timer">—</span>
  </div>

  <div id="interrupt-abilities" class="interrupt-list"></div>

  <div class="interrupt-footer">
    <button class="interrupt-skip" onclick="skipInterrupt()">ENDURE</button>
  </div>
</div>

<!-- INTERRUPTED OVERLAY -->
<div id="interrupt-overlay" class="interrupt-overlay hidden">
  <div class="interrupt-text">INTERRUPTED</div>
</div>

<!-- COMBAT RESULT OVERLAY -->
<div id="combat-result-overlay" class="result-overlay hidden">
  <div class="result-text" id="combat-result-text">VICTORY</div>
  <button class="result-continue" onclick="continueAfterCombat()">CONTINUE</button>
</div>

<!-- LOOT OVERLAY -->
<div id="loot-overlay" class="loot-overlay hidden" aria-hidden="true">
  <div class="loot-modal">
    <div class="loot-title">
      <div class="loot-h">SPOILS</div>
      <div class="loot-sub" id="loot-sub">Claim what the Dungeon allows.</div>
    </div>

    <div id="loot-items" class="loot-items"></div>

    <div class="loot-actions">
      <button id="loot-take-all" onclick="takeAllLoot()">TAKE ALL</button>
      <button class="secondary" onclick="continueFromLoot()">CONTINUE</button>
    </div>
  </div>
</div>

<script>
const API = "http://localhost:8000/step"; // adjust if needed
const EVENTS_API = "http://localhost:8000/events";
const CHARACTER_API = "http://localhost:8000/character";
const sessionId = crypto.randomUUID();
document.body.classList.add("chain-pulse");

const log = document.getElementById("log");
const combatLog = document.getElementById("combat-log");
const signalDot = document.getElementById("signal-dot");
const narrationWrapper = document.getElementById("narration-wrapper");
const narrationEl = document.getElementById("narration");
const mainScroll = document.getElementById("main-scroll");
const choicesEl = document.getElementById("choices");
const charHp = document.getElementById("char-hp");
const charRp = document.getElementById("char-rp");
    const charVeinscore = document.getElementById("char-veinscore");
    const statStr = document.getElementById("stat-str");
const statDex = document.getElementById("stat-dex");
const statInt = document.getElementById("stat-int");
const statWil = document.getElementById("stat-wil");
let signals = [];
let hasUnreadSignals = false;
let characterState = null;
let enemyState = null;
let abilityById = new Map();
const HEAT_CAP = 8;
const MOMENTUM_MAX = 8;

function addEntry(text, cls) {
  const div = document.createElement("div");
  div.className = `entry ${cls}`;
  div.textContent = text;
  log.appendChild(div);
  if (mainScroll) {
    mainScroll.scrollTop = mainScroll.scrollHeight;
  }
}

function clearChoices() {
  choicesEl.innerHTML = "";
}

async function sendStep(payload) {
  const res = await fetch(API, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ session_id: sessionId, ...payload })
  });

  const events = await res.json();
  handleEvents(events);
}

async function sendChoice(index) {
  clearChoices();
  await sendStep({ choice: index });
}

function clearNarration() {
  narrationEl.classList.add("fade-out");
  narrationWrapper.classList.add("smear-active");

  setTimeout(() => {
    narrationEl.innerHTML = "";
    narrationEl.classList.remove("fade-out");
    narrationEl.classList.add("fade-in");
    narrationWrapper.classList.remove("smear-active");
    setTimeout(() => narrationEl.classList.remove("fade-in"), 400);
  }, 400);
}

function appendNarration(text) {
  const p = document.createElement("p");
  p.textContent = text;
  p.style.opacity = "0";
  p.style.transition = "opacity 0.3s ease";
  narrationEl.appendChild(p);
  requestAnimationFrame(() => {
    p.style.opacity = "1";
  });
  if (mainScroll) {
    mainScroll.scrollTop = mainScroll.scrollHeight;
  }
}

function appendCombatLog(text) {
  logCombat(text);
}

function logCombat(text, type = "system") {
  const div = document.createElement("div");
  div.className = `log-entry ${type}`;
  div.textContent = text;
  combatLog.prepend(div);
  combatLog.scrollTop = 0;
}

function addSignal(type, text) {
  signals.unshift({ type, text });
  hasUnreadSignals = true;
  signalDot.classList.remove("hidden");
  renderSignals();
}

function renderSignals() {
  const host = document.getElementById("signal-list");
  host.innerHTML = "";

  signals.forEach(s => {
    const div = document.createElement("div");
    div.className = "signal";
    div.innerHTML = `<strong>${(s.type || "SYSTEM").toUpperCase()}</strong><br>${s.text}`;
    host.appendChild(div);
  });
}

function openSignals() {
  document.getElementById("signal-drawer").classList.remove("hidden");
  hasUnreadSignals = false;
  signalDot.classList.add("hidden");
}

function closeSignals() {
  document.getElementById("signal-drawer").classList.add("hidden");
}

function setCombatActive(active) {
  const card = document.getElementById("enemy-card");
  if (!card) return;
  if (active) {
    card.classList.remove("hidden");
  } else {
    card.classList.add("hidden");
  }
}

function flashInterrupt() {
  triggerInterruptFlash();
}

function triggerInterruptFlash() {
  document.body.classList.add("interrupt-flash");
  setTimeout(() => {
    document.body.classList.remove("interrupt-flash");
  }, 180);
}

function showInterruptOverlay(duration = 1500, text = "INTERRUPTED") {
  const overlay = document.getElementById("interrupt-overlay");
  if (!overlay) return;

  const textEl = overlay.querySelector(".interrupt-text");
  if (textEl && text) {
    textEl.textContent = text;
  }

  overlay.classList.remove("hidden");
  overlay.offsetHeight; // force reflow so transition fires
  overlay.classList.add("active");

  setTimeout(() => {
    overlay.classList.remove("active");
    setTimeout(() => overlay.classList.add("hidden"), 200);
  }, duration);
}

// INTERRUPT WINDOW UI
let interruptTimeout = null;
let interruptResizeBound = false;

function positionInterruptWindow() {
  const win = document.getElementById("interrupt-window");
  const main = document.getElementById("main");
  if (!win || !main) return;

  const rect = main.getBoundingClientRect();
  win.style.left = `${Math.round(rect.left)}px`;
  win.style.width = `${Math.round(rect.width)}px`;
  win.style.right = "auto";
}

function bindInterruptResize() {
  if (interruptResizeBound) return;
  interruptResizeBound = true;
  window.addEventListener("resize", () => {
    const win = document.getElementById("interrupt-window");
    if (!win) return;
    if (!win.classList.contains("hidden")) {
      positionInterruptWindow();
    }
  });
}

function openInterruptWindow(abilities, seconds = null) {
  clearChoices();
  try { closeChainBuilder(); } catch (e) { /* ignore */ }
  const win = document.getElementById("interrupt-window");
  const host = document.getElementById("interrupt-abilities");
  const timer = document.getElementById("interrupt-timer");

  if (!win || !host || !timer) {
    console.warn("interrupt_window: missing DOM nodes", { win, host, timer });
    return;
  }

  bindInterruptResize();
  positionInterruptWindow();

  host.innerHTML = "";
  const sec = (seconds === undefined || seconds === null) ? null : Number(seconds);
  timer.textContent = (sec && sec > 0) ? `${sec}s` : "—";

  (abilities || []).forEach(ab => {
    const card = document.createElement("div");
    card.className = "ability-card";

    card.innerHTML = `
      <div class="row">
        <div class="name">${ab.name}</div>
        <div class="meta">${ab.cost ?? 0} RP</div>
      </div>
      <div class="desc">${ab.effect ?? ""}</div>
    `;

    card.onclick = async () => {
      closeInterruptWindow();
      await sendStep({ action: "interrupt", ability: ab.id });
    };

    host.appendChild(card);
  });

  win.classList.remove("hidden");
  // Make it visible immediately; RAF just ensures transitions fire.
  win.classList.add("active");
  requestAnimationFrame(() => win.classList.add("active"));

  clearTimeout(interruptTimeout);
  interruptTimeout = null;
  // Do not auto-dismiss; the player must explicitly Endure or pick an interrupt ability.
}

function closeInterruptWindow() {
  const win = document.getElementById("interrupt-window");
  if (!win) return;
  win.classList.remove("active");
  setTimeout(() => win.classList.add("hidden"), 220);
  win.style.left = "";
  win.style.right = "";
  win.style.width = "";
}

async function skipInterrupt() {
  closeInterruptWindow();
  await sendStep({ action: "interrupt_skip" });
}

function showCombatResult(result) {
  const overlay = document.getElementById("combat-result-overlay");
  const text = document.getElementById("combat-result-text");
  if (!overlay || !text) return;

  const r = (result || "").toLowerCase();
  window.__lastCombatResult = r;
  if (r === "defeat") {
    text.textContent = "BLOOD MARK (DUN)";
    overlay.classList.add("defeat");
    const btn = overlay.querySelector(".result-continue");
    if (btn) btn.textContent = "RE-AWAKEN";
  } else {
    text.textContent = "VICTORY";
    overlay.classList.remove("defeat");
    const btn = overlay.querySelector(".result-continue");
    if (btn) btn.textContent = "CONTINUE";
  }

  overlay.classList.remove("hidden");
  overlay.offsetHeight;
  overlay.classList.add("active");
}

function applyEnemyUpdate(delta) {
  if (!delta) return;
  enemyState = { ...(enemyState || {}), ...delta };
  renderEnemyCard(enemyState);
}

function renderEnemyCard(enemy) {
  const card = document.getElementById("enemy-card");
  if (!card) return;
  card.classList.remove("hidden");

  const nameEl = document.getElementById("enemy-name");
  const metaEl = document.getElementById("enemy-meta");
  if (nameEl) nameEl.textContent = (enemy.name || "ENEMY").toUpperCase();

  const parts = [];
  if (enemy.tier !== undefined && enemy.tier !== null) parts.push(`T${enemy.tier}`);
  if (enemy.role) parts.push(String(enemy.role).toUpperCase());
  if (enemy.dv_base !== undefined && enemy.dv_base !== null) parts.push(`DV ${enemy.dv_base}`);
  if (enemy.idf !== undefined && enemy.idf !== null) parts.push(`IDF ${enemy.idf}`);
  if (metaEl) metaEl.textContent = parts.join(" · ");

  const hp = enemy.hp || {};
  const hpCur = Number(hp.current ?? hp.hp ?? 0);
  const hpMax = Number(hp.max ?? hp.max_hp ?? hpCur ?? 1);
  const hpPct = hpMax > 0 ? Math.max(0, Math.min(100, (hpCur / hpMax) * 100)) : 0;

  const hpFill = document.getElementById("enemy-hp-fill");
  const hpText = document.getElementById("enemy-hp-text");
  if (hpFill) hpFill.style.width = `${hpPct}%`;
  if (hpText) hpText.textContent = `${hpCur}/${hpMax}`;

  const heat = Number(enemy.heat ?? 0);
  const momentum = Number(enemy.momentum ?? 0);
  const balance = Number(enemy.balance ?? 0);

  const heatFill = document.getElementById("enemy-heat-fill");
  const heatText = document.getElementById("enemy-heat-text");
  if (heatFill) heatFill.style.width = `${Math.max(0, Math.min(100, (heat / HEAT_CAP) * 100))}%`;
  if (heatText) heatText.textContent = String(heat);

  const momFill = document.getElementById("enemy-mom-fill");
  const momText = document.getElementById("enemy-mom-text");
  if (momFill) momFill.style.width = `${Math.max(0, Math.min(100, (momentum / MOMENTUM_MAX) * 100))}%`;
  if (momText) momText.textContent = String(momentum);

  const BAL_CAP = 10;
  const balAbs = Math.min(BAL_CAP, Math.abs(balance));
  const balFill = document.getElementById("enemy-bal-fill");
  const balText = document.getElementById("enemy-bal-text");
  if (balFill) {
    balFill.style.width = `${Math.max(0, Math.min(100, (balAbs / BAL_CAP) * 100))}%`;
    balFill.style.background = balance < 0 ? "rgba(229, 75, 75, 0.9)" : "rgba(155, 179, 201, 0.85)";
  }
  if (balText) balText.textContent = String(balance);
}

async function continueAfterCombat() {
  const overlay = document.getElementById("combat-result-overlay");
  if (overlay) {
    overlay.classList.remove("active");
    setTimeout(() => overlay.classList.add("hidden"), 200);
  }
  const r = (window.__lastCombatResult || "").toLowerCase();
  if (r === "defeat") {
    await sendStep({ action: "defeat_continue" });
  } else {
    await sendStep({ action: "combat_loot" });
  }
}

function openLootScreen(items, summaryText) {
  clearChoices();
  try { closeChainBuilder(); } catch (e) { /* ignore */ }
  try { closeInterruptWindow(); } catch (e) { /* ignore */ }

  const overlay = document.getElementById("loot-overlay");
  const host = document.getElementById("loot-items");
  const sub = document.getElementById("loot-sub");
  if (!overlay || !host || !sub) return;

  host.innerHTML = "";
  sub.textContent = summaryText || "Claim what the Dungeon allows.";

  (items || []).forEach(it => {
    const row = document.createElement("div");
    row.className = "loot-item";
    const rarity = (it.rarity || "common").toUpperCase();
    const desc = it.description || it.narration || "";
    row.innerHTML = `
      <div class="loot-item-top">
        <div class="loot-item-name">${it.name || it.id || "Unknown"}</div>
        <div class="loot-item-rarity">${rarity}</div>
      </div>
      ${desc ? `<div class="loot-item-desc">${desc}</div>` : ""}
    `;
    host.appendChild(row);
  });

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  overlay.offsetHeight;
  overlay.classList.add("active");
}

function closeLootScreen() {
  const overlay = document.getElementById("loot-overlay");
  if (!overlay) return;
  overlay.classList.remove("active");
  setTimeout(() => {
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }, 200);
}

async function takeAllLoot() {
  await sendStep({ action: "loot_take_all" });
}

async function continueFromLoot() {
  closeLootScreen();
  await sendStep({ action: "loot_continue" });
}

function updateCharacterUI(char) {
  if (!char) return;
  if (char.hp) {
    const cur = char.hp.current ?? char.hp;
    const max = char.hp.max ?? char.hp_max ?? cur;
    charHp.textContent = `${cur}/${max}`;
  }
  if (char.rp !== undefined) {
    const rpCur = (typeof char.rp === "object" && char.rp) ? (char.rp.current ?? 0) : char.rp;
    const rpCap = (typeof char.rp === "object" && char.rp) ? char.rp.cap : undefined;
    charRp.textContent = (rpCap !== undefined && rpCap !== null) ? `${rpCur}/${rpCap}` : String(rpCur);
  }
  if (char.veinscore !== undefined) {
    charVeinscore.textContent = char.veinscore;
  }
  if (char.attributes) {
    statStr.textContent = char.attributes.str ?? "—";
    statDex.textContent = char.attributes.dex ?? "—";
    statInt.textContent = char.attributes.int ?? "—";
    statWil.textContent = char.attributes.wil ?? "—";
  }
  renderAbilitiesPanel(char);
}

function updateHeat(value) {
  const fill = document.getElementById("heat-fill");
  const val = document.getElementById("heat-value");
  const container = document.getElementById("heat-container");
  if (!fill || !val || !container) return;

  const clamped = Math.max(0, Math.min(Number(value ?? 0), HEAT_CAP));
  const pct = (clamped / HEAT_CAP) * 100;
  fill.style.width = pct + "%";
  val.textContent = String(clamped);

  if (clamped >= 5) container.classList.add("high");
  else container.classList.remove("high");
}

function updateMomentum(value, shocked = false) {
  const panel = document.getElementById("momentum-panel");
  const fill = document.getElementById("momentum-fill");
  const label = document.getElementById("momentum-value");
  if (!panel || !fill || !label) return;

  const clamped = Math.max(0, Math.min(MOMENTUM_MAX, Number(value ?? 0)));
  const pct = (clamped / MOMENTUM_MAX) * 100;

  label.textContent = String(clamped);
  fill.style.width = `${pct}%`;

  if (shocked) {
    panel.classList.add("momentum-shock");
    setTimeout(() => panel.classList.remove("momentum-shock"), 300);
  }
}

function updateBalance(value) {
  const panel = document.getElementById("balance-panel");
  const host = document.getElementById("balance-pips");
  if (!panel || !host) return;

  host.innerHTML = "";
  panel.classList.remove("hidden");

  const v = Number(value ?? 0);
  const abs = Math.abs(v);
  for (let i = 0; i < abs; i++) {
    const pip = document.createElement("div");
    pip.className = "balance-pip";
    if (v > 0) pip.classList.add("active");
    if (v < 0) pip.classList.add("negative");
    host.appendChild(pip);
  }
}

function wobbleBalance() {
  const panel = document.getElementById("balance-panel");
  if (!panel) return;
  panel.classList.add("balance-wobble");
  setTimeout(() => panel.classList.remove("balance-wobble"), 200);
}

function clearBalance() {
  const panel = document.getElementById("balance-panel");
  if (!panel) return;
  panel.classList.add("hidden");
}

function renderAbilitiesPanel(character) {
  const host = document.getElementById("abilities-list");
  host.innerHTML = "";

  if (!character?.abilities) return;

  character.abilities.forEach(ab => {
    const row = document.createElement("div");
    row.className = "ability-row";

    if (ab.cooldown && ab.cooldown > 0) {
      row.classList.add("cooldown");
    }

    const tags = (ab.tags || []).join(" · ");

    row.innerHTML = `
      <div class="top">
        <div class="name">${ab.name}</div>
        <div class="meta">
          ${ab.cost ? `${ab.cost} RP` : ""}
          ${ab.cooldown ? ` · CD ${ab.cooldown}` : ""}
        </div>
      </div>
      <div class="tags">
        ${ab.tier ? `T${ab.tier} · ` : ""}${tags}
      </div>
    `;

    host.appendChild(row);
  });
}

function renderChoices(prompt, options) {
  clearChoices();

  const p = document.createElement("div");
  p.className = "prompt";
  p.textContent = prompt;
  choicesEl.appendChild(p);

  options.forEach((opt, i) => {
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = `${i + 1}. ${opt}`;
    btn.onclick = () => sendChoice(i);
    choicesEl.appendChild(btn);
  });
}

function handleEvents(events) {
  events.forEach(ev => {
    switch (ev.type) {
      case "clear":
        if (ev.target === "narration" || ev.target === "all") {
          clearNarration();
        }
        if (ev.target === "choices" || ev.target === "all") {
          clearChoices();
        }
        if (ev.target === "log" || ev.target === "all") {
          log.innerHTML = "";
        }
        break;
      case "scene":
        appendNarration(ev.text);
        break;
      case "narration":
        appendNarration(ev.text);
        break;
      case "character_update":
        applyCharacterUpdate(ev.character);
        break;
      case "resource_update":
      case "resources_update":
        if (!characterState) characterState = {};
        if (!characterState.meters) characterState.meters = {};
        if (ev.heat !== undefined) updateHeat(ev.heat);
        if (ev.momentum !== undefined) updateMomentum(ev.momentum, !!ev.shocked);
        if (ev.balance !== undefined) updateBalance(ev.balance);
        if (ev.heat !== undefined) characterState.meters.heat = Number(ev.heat);
        if (ev.momentum !== undefined) characterState.meters.momentum = Number(ev.momentum);
        if (ev.balance !== undefined) characterState.meters.balance = Number(ev.balance);
        break;
      case "balance_update":
        if (ev.balance !== undefined) updateBalance(ev.balance);
        if (ev.wobble) wobbleBalance();
        break;
      case "chain_end":
        clearBalance();
        break;
      case "loot":
        addEntry(ev.text, "loot");
        break;
      case "system":
        addEntry(ev.text, "system");
        break;
      case "log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_state":
        setCombatActive(!!ev.active);
        break;
      case "enemy_update":
        applyEnemyUpdate(ev.enemy);
        break;
      case "combat_result":
        showCombatResult(ev.result);
        break;
      case "loot_screen":
        openLootScreen(ev.items || [], ev.summary);
        break;
      case "interrupt":
        flashInterrupt();
        if (ev.text) {
          logCombat(ev.text, "interrupt");
        }
        break;
      case "chain_interrupted":
        {
          const msg = ev.text || "Chain interrupted!";
          // If the enemy chain was interrupted (player countered), use a shorter label.
          const label = msg.toLowerCase().includes("enemy chain") ? "COUNTERED" : "INTERRUPTED";
          showInterruptOverlay(1500, label);
          logCombat(msg, "interrupt");
        }
        break;
      case "interrupt_window":
        flashInterrupt();
        openInterruptWindow(ev.abilities, ev.timeout ?? null);
        break;
      case "declare_chain":
        chainAbilities = ev.abilities || [];
        maxChainLength = Math.max(ev.maxLength ?? 6, 6);
        const maxEl = document.getElementById("chain-max");
        if (maxEl) {
          maxEl.textContent = String(maxChainLength);
        }
        chain = [];
        renderAbilities(chainAbilities);
        renderChain();
        renderChainRules(ev.chainRules);
        renderChainHint(ev.chainRules);
        openChainBuilder();
        break;
      case "signal":
        addSignal(ev.signalType || "system", ev.text);
        break;
      case "chain_rejected":
        rejectChain(ev.reason);
        break;
      case "choice":
        renderChoices(ev.prompt, ev.options);
        break;
    }
  });
}

function applyCharacterUpdate(delta) {
  if (!delta) return;
  if (!characterState) {
    characterState = { abilities: [] };
  }
  if (delta.name !== undefined) characterState.name = delta.name;
  if (delta.hp !== undefined) characterState.hp = delta.hp;
  if (delta.rp !== undefined) characterState.rp = delta.rp;
  if (delta.veinscore !== undefined) characterState.veinscore = delta.veinscore;
  if (delta.meters && typeof delta.meters === "object") {
    characterState.meters = { ...(characterState.meters || {}), ...delta.meters };
    if (delta.meters.heat !== undefined) updateHeat(delta.meters.heat);
    if (delta.meters.momentum !== undefined) updateMomentum(delta.meters.momentum);
    if (delta.meters.balance !== undefined) updateBalance(delta.meters.balance);
  }

  if (Array.isArray(delta.abilities)) {
    delta.abilities.forEach(a => {
      if (!a || !a.id) return;
      const existing = abilityById.get(a.id) || { id: a.id, name: a.id };
      if (a.cooldown !== undefined) existing.cooldown = a.cooldown;
      abilityById.set(a.id, existing);
    });
    characterState.abilities = Array.from(abilityById.values());
  }

  updateCharacterUI(characterState);
  renderAbilitiesPanel(characterState);
}

// initial kick
fetch(API, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    session_id: sessionId,
    action: "start"
  })
})
  .then(res => res.json())
  .then(handleEvents);

fetch(CHARACTER_API)
  .then(res => res.json())
  .then(ch => {
    characterState = ch;
    abilityById = new Map();
    if (Array.isArray(ch?.abilities)) {
      ch.abilities.forEach(ab => {
        if (!ab) return;
        const id = ab.id || ab.name;
        if (!id) return;
        abilityById.set(id, { ...ab, id });
      });
    }
    updateCharacterUI(characterState);
    renderAbilitiesPanel(characterState);
  });

async function pollEvents() {
  try {
    const res = await fetch(EVENTS_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ session_id: sessionId })
    });

    const events = await res.json();
    if (Array.isArray(events) && events.length) {
      handleEvents(events);
    }
  } catch (err) {
    console.error("pollEvents failed", err);
  }
}

setInterval(pollEvents, 12000000);

// CHAIN BUILDER STATE AND HELPERS
let chainAbilities = []; // from backend event
let chain = [];
let maxChainLength = 6;

function openChainBuilder() {
  clearChoices();
  document.body.classList.add("chain-active");
  document.body.classList.add("chain-pulse-active");
  const ov = document.getElementById("chain-overlay");
  ov.classList.remove("hidden");
  ov.setAttribute("aria-hidden", "false");
}

function closeChainBuilder() {
  const ov = document.getElementById("chain-overlay");

  // 1. MOVE FOCUS FIRST
  const narration = document.getElementById("narration");
  if (narration) {
    narration.setAttribute("tabindex", "-1");
    narration.focus();
  } else {
    document.body.focus();
  }

  // 2. THEN hide visually + semantically
  document.body.classList.remove("chain-active");
  document.body.classList.remove("chain-pulse-active");
  ov.classList.add("hidden");
  ov.setAttribute("aria-hidden", "true");
}


function clearChain() {
  chain = [];
  renderChain();
}

function removeFromChain(i) {
  chain.splice(i, 1);
  renderChain();
}

function addToChain(ability) {
  if (chain.length >= maxChainLength) return;
  chain.push(ability);
  renderChain();
}

function abilityIsUsable(ab) {
  const cd = ab.cooldown ?? 0;
  return cd === 0 && !ab.disabled;
}

function renderAbilities(abilities) {
  const buckets = {
    attack: document.getElementById("attack-abilities"),
    defense: document.getElementById("defense-abilities"),
    utility: document.getElementById("utility-abilities"),
    movement: document.getElementById("movement-abilities"),
  };

  Object.values(buckets).forEach(el => el.innerHTML = "");

  abilities.forEach(ab => {
    const type = (ab.type || "").toLowerCase();
    const host = buckets[type];
    if (!host) return;

    const card = document.createElement("div");
    card.className = "ability-card";

    const usable = abilityIsUsable(ab);
    if (!usable) card.classList.add("disabled");

    const cost = (ab.cost ?? 0);
    const cd = (ab.cooldown ?? 0);

    card.innerHTML = `
      <div class="row">
        <div class="name">${ab.name}</div>
        <div class="meta">COST ${cost}${cd ? ` · CD ${cd}` : ""}</div>
      </div>
      ${ab.effect ? `<div class="desc">${ab.effect}</div>` : ""}
    `;

    if (usable) {
      card.onclick = () => addToChain(ab);
    }

    host.appendChild(card);
  });
}

function renderChain() {
 

  const slots = document.getElementById("chain-slots");
  slots.innerHTML = "";

  for (let i = 0; i < maxChainLength; i++) {
    const slot = document.createElement("div");
    slot.className = "chain-slot";

    if (chain[i]) {
      slot.classList.add("filled");
      slot.textContent = chain[i].name;
      slot.onclick = () => removeFromChain(i);
    } else {
      slot.textContent = "—";
    }

    slots.appendChild(slot);
  }

  const commit = document.getElementById("chain-commit");
  commit.disabled = false;
}

async function submitChain() {
  const ids = chain.map(a => a.id);

  closeChainBuilder();
  // Clear main output so the next chain resolution reads cleanly.
  clearNarration();
  log.innerHTML = "";
  await sendStep({
    action: "declare_chain",
    chain: ids
  });
}

function rejectChain(reasonText) {
  const ov = document.getElementById("chain-overlay");

  ov.classList.add("chain-reject");

  if (reasonText) {
    logCombat(reasonText, "system");
  }

  setTimeout(() => {
    ov.classList.remove("chain-reject");
  }, 400);
}

function renderChainRules(rules) {
  const sub = document.getElementById("chain-sub");
  const span = document.getElementById("chain-max");

  const min = rules?.min ?? 0;
  const max = rules?.max ?? maxChainLength;
  if (span) {
    span.textContent = String(max);
  }

  if (min === 0 && max) {
    sub.textContent = `Build a chain of up to ${max} links — or stand and endure.`;
  } else if (max && max > min) {
    sub.textContent = `Build a chain of ${min}–${max} links.`;
  } else if (max) {
    sub.textContent = `Build a chain of up to ${max} links.`;
  } else {
    sub.textContent = "Build your chain — or take the hit.";
  }

  if (rules?.source) {
    sub.textContent += ` (${rules.source})`;
  }
}

function renderChainHint(rules) {
  const hint = document.getElementById("chain-hint");

  if (rules?.min === 0) {
    hint.textContent = "Commit with an empty chain to brace and endure.";
  } else {
    hint.textContent = "Click a filled slot to remove it.";
  }
}

</script>

</body>

</html>
