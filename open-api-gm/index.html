<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>VEINBREAKER</title>

  <style>
    :root {
      --bg: #0b0d0f;
      --fg: #d6d6d6;
      --dim: #8a8a8a;
      --accent: #9e2b25;
      --line: #1e2226;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 14px;
    }

    header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      color: var(--dim);
      letter-spacing: 2px;
    }

    #log {
      padding: 16px;
      max-width: 900px;
      margin: 0 auto;
      min-height: 60vh;
    }

    .entry {
      margin-bottom: 12px;
      white-space: pre-wrap;
    }

    .scene {
      color: var(--dim);
    }

    .narration {
      color: var(--fg);
    }

    .loot {
      color: var(--accent);
    }

    .system {
      color: var(--dim);
      font-style: italic;
    }

footer {
  border-top: 1px solid var(--line);
  padding: 12px 16px;
  flex-shrink: 0;
  background: var(--bg);
}

    .combat-mode #narration-wrapper::after {
      background:
        radial-gradient(circle at 40% 30%, rgba(180, 0, 0, 0.25), transparent 60%),
        radial-gradient(circle at 60% 70%, rgba(120, 0, 0, 0.2), transparent 65%);
    }

    .choice {
      display: block;
      background: none;
      border: none;
      color: var(--fg);
      text-align: left;
      padding: 6px 0;
      cursor: pointer;
      font-family: inherit;
    }

    .choice:hover {
      color: var(--accent);
    }

    .prompt {
      color: var(--dim);
      margin-bottom: 8px;
    }

  #layout {
    display: flex;
    height: calc(100vh - 48px);
  }
/* ===== CHAIN OVERLAY ===== */
#chain-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  backdrop-filter: blur(3px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#chain-overlay.hidden {
  display: none;
}

.chain-active #narration-wrapper {
  opacity: 0.28;
  filter: blur(2px);
}

.chain-active #log,
.chain-active footer {
  opacity: 0.55;
}

.chain-modal {
  width: min(1100px, 92vw);
  max-height: 86vh;
  overflow: auto;
  background: #0d0d0d;
  border: 1px solid var(--accent);
  box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.2);
  padding: 14px 14px 16px;
}

.chain-title {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--line);
  padding-bottom: 10px;
  margin-bottom: 12px;
}

.chain-h {
  letter-spacing: 3px;
  color: var(--fg);
  font-size: 12px;
}

.chain-sub {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
}

.chain-close {
  background: none;
  border: 1px solid var(--line);
  color: var(--dim);
  cursor: pointer;
  font-family: inherit;
  padding: 6px 10px;
}

.chain-close:hover {
  border-color: var(--accent);
  color: var(--fg);
}

.chain-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.ability-column h3 {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--dim);
  margin: 0 0 8px;
}

.ability-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.ability-card {
  border: 1px solid var(--line);
  background: #101113;
  padding: 10px 10px 9px;
  cursor: pointer;
  transition: border-color 0.12s ease, transform 0.12s ease;
}

.ability-card:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.ability-card.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none;
}

.ability-card .row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.ability-card .name {
  color: var(--fg);
  font-size: 13px;
}

.ability-card .meta {
  color: var(--dim);
  font-size: 12px;
}

.ability-card .desc {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
  line-height: 1.35;
}

.chain-preview {
  border-top: 1px solid var(--line);
  margin-top: 14px;
  padding-top: 12px;
}

#chain-slots {
  display: flex;
  gap: 10px;
  margin: 10px 0 12px;
  flex-wrap: wrap;
}

.chain-slot {
  width: 150px;
  height: 54px;
  border: 1px dashed var(--line);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--dim);
}

.chain-slot.filled {
  border-style: solid;
  background: rgba(158, 43, 37, 0.12);
  color: var(--fg);
  cursor: pointer;
}

.chain-actions {
  display: flex;
  gap: 10px;
}

#chain-commit {
  border: 1px solid var(--accent);
  background: rgba(158, 43, 37, 0.15);
  color: var(--fg);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

#chain-commit:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.secondary {
  border: 1px solid var(--line);
  background: none;
  color: var(--dim);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

.secondary:hover {
  border-color: var(--accent);
  color: var(--fg);
}

  .chain-hint {
    margin-top: 10px;
    color: var(--dim);
    font-size: 12px;
  }

  /* ===== ABILITIES PANEL ===== */

  #abilities-panel {
    margin-top: 16px;
    border-top: 1px solid var(--line);
    padding-top: 10px;
  }

  #abilities-panel .panel-title {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--dim);
    margin-bottom: 8px;
  }

  #abilities-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .ability-row {
    border: 1px solid var(--line);
    padding: 6px 8px;
    background: #101113;
    font-size: 12px;
  }

	  .ability-row.cooldown {
	    border-color: rgba(158, 43, 37, 0.55);
	    background: rgba(158, 43, 37, 0.08);
	  }

	  .ability-row.cooldown .name {
	    color: #e07070;
	  }

	  .ability-row.cooldown .meta,
	  .ability-row.cooldown .tags {
	    color: rgba(224, 112, 112, 0.8);
	  }

  .ability-row .top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }

  .ability-row .name {
    color: var(--fg);
  }

  .ability-row .meta {
    color: var(--dim);
    font-size: 11px;
  }

	  .ability-row .tags {
	    margin-top: 4px;
	    font-size: 10px;
	    color: var(--dim);
	    text-transform: uppercase;
	    letter-spacing: 1px;
	  }

	  /* ===== SAFE ROOM OVERLAY ===== */

	  .safe-room-overlay {
	    position: fixed;
	    inset: 0;
	    z-index: 1900;
	    background: rgba(0, 0, 0, 0.78);
	    display: flex;
	    align-items: center;
	    justify-content: center;
	  }

	  .safe-room-overlay.hidden {
	    display: none;
	  }

	  .safe-room-modal {
	    width: min(860px, 92vw);
	    max-height: 86vh;
	    overflow: hidden;
	    border: 1px solid rgba(158, 43, 37, 0.35);
	    background: #0b0c0e;
	    box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.12), 0 18px 80px rgba(0, 0, 0, 0.6);
	    display: flex;
	    flex-direction: column;
	  }

	  .safe-room-header {
	    display: flex;
	    justify-content: space-between;
	    align-items: baseline;
	    padding: 12px 14px;
	    border-bottom: 1px solid var(--line);
	    letter-spacing: 2px;
	    color: var(--fg);
	  }

	  .safe-room-header .vein {
	    color: var(--dim);
	    font-size: 12px;
	  }

	  .safe-room-body {
	    padding: 12px 14px;
	    overflow-y: auto;
	  }

	  .safe-room-character {
	    color: var(--dim);
	    font-size: 12px;
	    margin-bottom: 12px;
	    border: 1px solid var(--line);
	    background: #101113;
	    padding: 10px 12px;
	  }

	  .safe-room-shop .panel-title {
	    font-size: 11px;
	    letter-spacing: 2px;
	    color: var(--dim);
	    margin-bottom: 8px;
	  }

	  .safe-room-progression .panel-title {
	    font-size: 11px;
	    letter-spacing: 2px;
	    color: var(--dim);
	    margin-bottom: 8px;
	  }

	  .safe-room-progression-text {
	    border: 1px solid var(--line);
	    background: #101113;
	    padding: 10px 12px;
	    color: var(--dim);
	    font-size: 12px;
	    line-height: 1.35;
	  }

	  .safe-room-rest-result {
	    margin-top: 8px;
	    border: 1px solid rgba(158, 43, 37, 0.35);
	    background: rgba(158, 43, 37, 0.08);
	    padding: 10px 12px;
	    color: var(--fg);
	    font-size: 12px;
	    line-height: 1.35;
	  }

	  .safe-room-rest-result.hidden {
	    display: none;
	  }

	  /* ===== CHARACTER CREATE (reuses safe-room overlay) ===== */

	  .character-create-panel.hidden {
	    display: none;
	  }

	  .character-create-field {
	    margin-top: 10px;
	    border: 1px solid var(--line);
	    background: #101113;
	    padding: 10px 12px;
	  }

	  .character-create-field .label {
	    font-size: 10px;
	    letter-spacing: 2px;
	    color: var(--dim);
	    margin-bottom: 6px;
	  }

	  .character-create-input {
	    width: 100%;
	    background: #0b0c0e;
	    border: 1px solid rgba(158, 43, 37, 0.35);
	    color: var(--fg);
	    padding: 8px 10px;
	    outline: none;
	  }

	  .character-create-buttons {
	    display: flex;
	    flex-wrap: wrap;
	    gap: 8px;
	    margin: 10px 0 14px;
	  }

	  .safe-room-offer {
	    border: 1px solid var(--line);
	    background: #101113;
	    padding: 10px 12px;
	    margin-bottom: 8px;
	  }

	  .safe-room-offer .row {
	    display: flex;
	    justify-content: space-between;
	    gap: 12px;
	    align-items: baseline;
	  }

	  .safe-room-offer .name {
	    color: var(--fg);
	  }

	  .safe-room-offer .meta {
	    color: var(--dim);
	    font-size: 12px;
	    white-space: nowrap;
	  }

	  .safe-room-offer .desc {
	    margin-top: 6px;
	    color: var(--dim);
	    font-size: 12px;
	    line-height: 1.35;
	  }

	  .safe-room-offer button {
	    margin-top: 10px;
	    background: none;
	    border: 1px solid rgba(158, 43, 37, 0.55);
	    color: var(--fg);
	    padding: 6px 10px;
	    cursor: pointer;
	  }

	  .safe-room-offer button:disabled {
	    opacity: 0.45;
	    cursor: not-allowed;
	  }

	  .safe-room-actions {
	    display: flex;
	    justify-content: space-between;
	    gap: 10px;
	    padding: 12px 14px;
	    border-top: 1px solid var(--line);
	    background: #0b0c0e;
	    flex-shrink: 0;
	  }

	  .safe-room-actions button.secondary {
	    border-color: var(--line);
	    color: var(--dim);
	  }

	  /* ===== ENEMY BADGES ===== */

	  .monster-badges {
	    display: flex;
	    align-items: center;
	    gap: 8px;
	  }

	  .enemy-badge {
	    border: 1px solid rgba(229, 75, 75, 0.65);
	    color: #e54b4b;
	    background: rgba(229, 75, 75, 0.08);
	    padding: 3px 8px;
	    font-size: 10px;
	    letter-spacing: 0.25em;
	    text-transform: uppercase;
	  }

	  .enemy-badge.hidden {
	    display: none;
	  }
	  
	  .enemy-badge.bleed {
	    border-color: rgba(255, 105, 97, 0.7);
	    color: #ff6a6a;
	    background: rgba(255, 106, 106, 0.08);
	  }

	  /* ===== START MENU (slide-up) ===== */

	  .start-menu {
	    position: fixed;
	    left: 0;
	    right: 0;
	    bottom: 0;
	    z-index: 1950;
	    display: flex;
	    justify-content: center;
	    pointer-events: none;
	  }

	  .start-menu.hidden {
	    display: none;
	  }

	  .start-sheet {
	    width: min(720px, 94vw);
	    border: 1px solid rgba(158, 43, 37, 0.35);
	    background: #0b0c0e;
	    box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.12), 0 18px 80px rgba(0, 0, 0, 0.6);
	    transform: translateY(110%);
	    transition: transform 0.22s ease-out;
	    padding: 14px 16px;
	    pointer-events: auto;
	  }

	  .start-menu.active .start-sheet {
	    transform: translateY(0);
	  }

	  .start-title {
	    letter-spacing: 3px;
	    font-size: 12px;
	    color: var(--fg);
	    margin-bottom: 6px;
	  }

	  .start-sub {
	    color: var(--dim);
	    font-size: 12px;
	    margin-bottom: 12px;
	  }

	  .start-actions {
	    display: flex;
	    gap: 10px;
	    flex-wrap: wrap;
	  }

	  .start-actions button {
	    background: none;
	    border: 1px solid rgba(158, 43, 37, 0.55);
	    color: var(--fg);
	    padding: 8px 10px;
	    cursor: pointer;
	  }

	  .start-actions button.secondary {
	    border-color: var(--line);
	    color: var(--dim);
	  }

	  .load-character-panel {
	    margin-top: 12px;
	    padding-top: 12px;
	    border-top: 1px solid var(--line);
	  }

	  .load-character-panel.hidden {
	    display: none;
	  }

	  #character-list {
	    display: flex;
	    flex-direction: column;
	    gap: 8px;
	  }

	  .character-row {
	    border: 1px solid var(--line);
	    background: #101113;
	    padding: 8px 10px;
	    display: flex;
	    justify-content: space-between;
	    gap: 10px;
	    cursor: pointer;
	  }

	  .character-row .meta {
	    color: var(--dim);
	    font-size: 12px;
	    white-space: nowrap;
	  }

		@keyframes chain-heartbeat {
		  0% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
  35% {
    box-shadow:
      0 0 16px 4px rgba(158, 43, 37, 0.35),
      inset 0 0 10px 2px rgba(158, 43, 37, 0.28);
  }
  70% {
    box-shadow:
      0 0 10px 3px rgba(158, 43, 37, 0.22),
      inset 0 0 6px 2px rgba(158, 43, 37, 0.18);
  }
  100% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
}

  .chain-pulse .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
  }
  /* Alternate trigger for visibility-based pulse */
  .chain-pulse-active .chain-modal {
    animation: chain-heartbeat 1.4s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.65);
  }
  /* Keep the pulse active whenever the overlay is visible, even if chain-pulse isn't toggled */
  #chain-overlay:not(.hidden) .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.55);
  }

@keyframes chain-reject-shake {
  0%   { transform: translateX(0); }
  15%  { transform: translateX(-6px); }
  30%  { transform: translateX(6px); }
  45%  { transform: translateX(-4px); }
  60%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

@keyframes chain-reject-flash {
  0%   { background-color: rgba(180, 0, 0, 0.35); }
  100% { background-color: transparent; }
}

.chain-reject .chain-modal {
  animation: chain-reject-shake 0.35s ease;
}

.chain-reject::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(180, 0, 0, 0.25);
  animation: chain-reject-flash 0.25s ease-out;
  pointer-events: none;
  z-index: 1001;
}

  #character-panel {
    width: 180px;
    padding: 16px 12px;
    border-right: 1px solid var(--line);
      color: var(--dim);
    }

    .vein-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .vein-node {
      width: 64px;
      height: 64px;
      border: 1px solid var(--accent);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle, rgba(158, 43, 37, 0.15), transparent 70%);
    }

    .vein-node .label {
      font-size: 10px;
      letter-spacing: 1px;
      color: var(--dim);
    }

    .vein-node .value {
      font-size: 18px;
      color: var(--fg);
    }

    .stats {
      border-top: 1px solid var(--line);
      padding-top: 12px;
      font-size: 12px;
    }

  .stats div {
    display: flex;
    justify-content: space-between;
    margin: 4px 0;
  }

  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-width: 0;
  }

  #main-scroll {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 12px;
  }

  /* ===== ENEMY CARD ===== */

  .monster-card {
    border-bottom: 1px solid var(--line);
    padding: 10px 14px;
    background: linear-gradient(180deg, rgba(16, 17, 19, 0.95), rgba(12, 12, 12, 0.9));
  }

  .monster-card.hidden {
    display: none;
  }

  .monster-top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 8px;
  }

  .monster-name {
    color: var(--fg);
    letter-spacing: 2px;
    font-size: 12px;
    text-transform: uppercase;
  }

  .monster-meta {
    color: var(--dim);
    font-size: 11px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .monster-meters {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .meter-row {
    display: grid;
    grid-template-columns: 34px 1fr 56px;
    gap: 8px;
    align-items: center;
    font-size: 11px;
    color: var(--dim);
  }

  .meter-label {
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .meter-value {
    text-align: right;
    color: var(--fg);
    font-variant-numeric: tabular-nums;
  }

  .meter-bar {
    height: 10px;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 2px;
    overflow: hidden;
  }

  .meter-fill {
    height: 100%;
    width: 0%;
    transition: width 0.2s ease;
    background: rgba(158, 43, 37, 0.75);
  }

  .meter-bar.hp .meter-fill { background: rgba(158, 43, 37, 0.85); }
  .meter-bar.heat .meter-fill { background: linear-gradient(90deg, #ff9f1c, #ff3d00); }
  .meter-bar.mom .meter-fill { background: linear-gradient(90deg, #4f7cff, #79a6ff); }

  #combat-log-panel {
    width: 260px;
    border-left: 1px solid var(--line);
    padding: 12px;
    font-size: 12px;
    color: var(--dim);
    background: #0b0b0b;
    position: relative;
  }

  #combat-log-header {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--fg);
    margin-bottom: 8px;
    opacity: 0.8;
    display: flex;
    align-items: center;
    cursor: pointer;
  }

  #signal-dot {
    width: 8px;
    height: 8px;
    background: rgba(158, 43, 37, 0.9);
    border-radius: 50%;
    margin-left: 8px;
    animation: signal-pulse 1.6s ease-in-out infinite;
  }

  #signal-dot.hidden {
    display: none;
  }

  @keyframes signal-pulse {
    0% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
    50% { box-shadow: 0 0 8px rgba(158,43,37,0.6); }
    100% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
  }

  #combat-log {
    max-height: calc(100vh - 60px);
    overflow-y: auto;
    padding-right: 6px;
  }

  .log-entry {
    margin-bottom: 6px;
    line-height: 1.4;
  }

  .log-entry.attack { color: #c9c9c9; }
  .log-entry.damage { color: #e07070; }
  .log-entry.block  { color: #7fa6ff; }
  .log-entry.system { color: #888; }
  .log-entry.interrupt { color: #ff8484; }
  .log-entry.roll { color: #e07070; font-weight: 600; }

  #main-scroll::-webkit-scrollbar,
  #combat-log::-webkit-scrollbar {
    width: 6px;
  }

  #main-scroll::-webkit-scrollbar-track,
  #combat-log::-webkit-scrollbar-track {
    background: transparent;
  }

  #main-scroll::-webkit-scrollbar-thumb,
  #combat-log::-webkit-scrollbar-thumb {
    background-color: rgba(158, 43, 37, 0.35);
    border-radius: 6px;
  }

  #main-scroll::-webkit-scrollbar-thumb:hover,
  #combat-log::-webkit-scrollbar-thumb:hover {
    background-color: rgba(158, 43, 37, 0.6);
  }

  .signal-drawer {
    position: absolute;
    right: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: #0b0c0e;
    border-left: 1px solid var(--line);
    z-index: 20;
  }

  .signal-drawer.hidden {
    display: none;
  }

  .signal-drawer-header {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    display: flex;
    justify-content: space-between;
    letter-spacing: 2px;
    font-size: 11px;
    color: var(--fg);
  }

  .signal {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    background: rgba(158, 43, 37, 0.12);
    color: var(--fg);
  }

  /* Interrupt flash */
@keyframes interrupt-flash {
  0%   { background-color: rgba(180, 0, 0, 0.15); }
  50%  { background-color: rgba(180, 0, 0, 0.35); }
  100% { background-color: transparent; }
}

.interrupt-flash {
  animation: interrupt-flash 0.18s ease-out;
}

/* ===== INTERRUPT SLIDE-UP ===== */
#interrupt-window {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: 42vh;
  background: linear-gradient(to top, #0b0c0e, #0f1114);
  border-top: 2px solid var(--accent);
  z-index: 1100;
  transform: translateY(100%);
  transition: transform 0.22s ease-out;
}

#interrupt-window.active {
  transform: translateY(0);
}

#interrupt-window.hidden {
  display: none;
}

.interrupt-header {
  display: flex;
  justify-content: space-between;
  padding: 10px 14px;
  letter-spacing: 2px;
  font-size: 11px;
  color: var(--fg);
  border-bottom: 1px solid var(--line);
}

.interrupt-list {
  padding: 12px;
  display: flex;
  gap: 10px;
  overflow-x: auto;
}

.interrupt-list .ability-card {
  min-width: 220px;
  border-color: rgba(158, 43, 37, 0.6);
}

.interrupt-footer {
  padding: 10px;
  border-top: 1px solid var(--line);
  text-align: right;
}

.interrupt-skip {
  background: none;
  border: 1px solid var(--line);
  color: var(--dim);
  padding: 6px 12px;
  cursor: pointer;
}

.interrupt-skip:hover {
  border-color: var(--accent);
  color: var(--fg);
}

/* ===== EXECUTE WINDOW ===== */

#execute-window {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: 42vh;
  background: linear-gradient(to top, #0b0c0e, #0f1114);
  border-top: 2px solid var(--accent);
  z-index: 1150;
  transform: translateY(100%);
  transition: transform 0.22s ease-out;
}

#execute-window.active {
  transform: translateY(0);
}

#execute-window.hidden {
  display: none;
}

.execute-header {
  display: flex;
  justify-content: space-between;
  padding: 10px 14px;
  letter-spacing: 2px;
  font-size: 11px;
  color: var(--fg);
  border-bottom: 1px solid var(--line);
}

.execute-body {
  padding: 12px 14px;
  color: var(--fg);
  font-size: 13px;
  line-height: 1.35;
}

.execute-footer {
  padding: 10px 14px;
  border-top: 1px solid var(--line);
  text-align: right;
}

.execute-footer button {
  background: none;
  border: 1px solid rgba(158, 43, 37, 0.55);
  color: var(--fg);
  padding: 6px 12px;
  cursor: pointer;
  margin-left: 10px;
}

.execute-footer button.secondary {
  border-color: var(--line);
  color: var(--dim);
}

.execute-footer button:hover {
  border-color: var(--accent);
  color: var(--fg);
}

/* ===== INTERRUPTED OVERLAY ===== */
.interrupt-overlay {
  position: fixed;
  inset: 0;
  /* Keep below the interrupt chooser so it never blocks selection */
  z-index: 1050;
  background: radial-gradient(
    circle at center,
    rgba(180, 30, 30, 0.25),
    rgba(0, 0, 0, 0.85)
  );
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  opacity: 0;
  transform: scale(1.02);
  transition: opacity 0.15s ease-out, transform 0.15s ease-out;
}

.interrupt-overlay.active {
  opacity: 1;
  transform: scale(1);
}

.interrupt-overlay.hidden {
  display: none;
}

  .interrupt-text {
    font-family: inherit;
    font-size: clamp(48px, 8vw, 96px);
    letter-spacing: 0.3em;
    color: #e54b4b;
  text-shadow:
    0 0 8px rgba(229, 75, 75, 0.6),
    0 0 24px rgba(229, 75, 75, 0.4),
    0 0 48px rgba(229, 75, 75, 0.25);
  animation: interrupt-smear 0.18s steps(2) 3;
}

  @keyframes interrupt-smear {
    0%   { transform: translateX(0); }
    33%  { transform: translateX(-6px); }
    66%  { transform: translateX(6px); }
    100% { transform: translateX(0); }
  }

  /* ===== LOOT OVERLAY ===== */

  .loot-overlay {
    position: fixed;
    inset: 0;
    z-index: 1600;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.78);
    opacity: 0;
    transition: opacity 0.18s ease-out;
  }

  .loot-overlay.active {
    opacity: 1;
  }

  .loot-overlay.hidden {
    display: none;
  }

  .loot-modal {
    width: min(720px, calc(100vw - 32px));
    max-height: min(72vh, 720px);
    display: flex;
    flex-direction: column;
    border: 1px solid var(--line);
    background: linear-gradient(180deg, #0f1114, #0b0c0e);
    box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.18), 0 18px 60px rgba(0, 0, 0, 0.55);
  }

  .loot-title {
    padding: 12px 14px;
    border-bottom: 1px solid var(--line);
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .loot-h {
    letter-spacing: 3px;
    font-size: 12px;
    color: var(--fg);
  }

  .loot-sub {
    font-size: 12px;
    color: var(--dim);
  }

  .loot-items {
    padding: 12px 14px;
    overflow: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .loot-item {
    border: 1px solid var(--line);
    background: #101113;
    padding: 10px 10px;
  }

  .loot-item-top {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: baseline;
  }

  .loot-item-name {
    color: var(--fg);
    font-size: 13px;
  }

  .loot-item-rarity {
    color: var(--dim);
    font-size: 11px;
    letter-spacing: 2px;
  }

  .loot-item-desc {
    margin-top: 6px;
    color: var(--dim);
    font-size: 12px;
    line-height: 1.35;
  }

  .loot-actions {
    padding: 12px 14px;
    border-top: 1px solid var(--line);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
  }

/* ===== COMBAT RESULT OVERLAY ===== */
.result-overlay {
  position: fixed;
  inset: 0;
  z-index: 2100;
  background: radial-gradient(circle at center, rgba(30, 180, 80, 0.18), rgba(0, 0, 0, 0.88));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 18px;
  opacity: 0;
  transform: scale(1.02);
  transition: opacity 0.15s ease-out, transform 0.15s ease-out;
}

.result-overlay.defeat {
  background: radial-gradient(circle at center, rgba(180, 30, 30, 0.18), rgba(0, 0, 0, 0.88));
}

.result-overlay.active {
  opacity: 1;
  transform: scale(1);
}

.result-overlay.hidden {
  display: none;
}

.result-text {
  font-family: inherit;
  font-size: clamp(48px, 8vw, 96px);
  letter-spacing: 0.22em;
  color: var(--fg);
  text-shadow:
    0 0 8px rgba(255, 255, 255, 0.15),
    0 0 24px rgba(255, 255, 255, 0.08);
}

.result-overlay.defeat .result-text {
  color: #e54b4b;
  text-shadow:
    0 0 8px rgba(229, 75, 75, 0.6),
    0 0 24px rgba(229, 75, 75, 0.35);
}

.result-continue {
  background: none;
  border: 1px solid var(--line);
  color: var(--fg);
  padding: 10px 18px;
  letter-spacing: 2px;
  cursor: pointer;
}

.result-continue:hover {
  border-color: var(--accent);
}

/* ===== HEAT METER ===== */
.heat-container {
  margin-top: 10px;
}

.heat-label {
  font-size: 10px;
  letter-spacing: 2px;
  color: #ffb347;
  margin-bottom: 4px;
}

.heat-bar {
  position: relative;
  height: 10px;
  background: #1a0f08;
  border: 1px solid #3a1d0f;
  overflow: hidden;
}

.heat-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #ff9f1c, #ff6f00, #ff3d00);
  box-shadow:
    0 0 6px rgba(255, 140, 0, 0.6),
    0 0 12px rgba(255, 90, 0, 0.4);
  transition: width 0.25s ease, box-shadow 0.25s ease;
}

.heat-container.high .heat-fill {
  animation: heat-pulse 0.8s infinite alternate;
}

@keyframes heat-pulse {
  from { box-shadow: 0 0 10px rgba(255, 100, 0, 0.8); }
  to   { box-shadow: 0 0 18px rgba(255, 50, 0, 1); }
}

.heat-value {
  font-size: 11px;
  color: #ffcc80;
  margin-top: 4px;
  text-align: right;
}

/* ===== MOMENTUM ===== */
.momentum-panel {
  margin-top: 10px;
}

.momentum-header {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  letter-spacing: 0.15em;
  color: #9bb3c9;
}

.momentum-bar {
  position: relative;
  height: 10px;
  background: #14181c;
  border-radius: 2px;
  overflow: hidden;
}

#momentum-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #4f7cff, #79a6ff);
  box-shadow: 0 0 6px rgba(79, 124, 255, 0.4);
  transition: width 0.25s ease-out;
}

.momentum-shock #momentum-fill {
  animation: momentum-shock 0.25s ease-out;
}

@keyframes momentum-shock {
  0%   { filter: brightness(1.6); }
  100% { filter: brightness(1); }
}

/* ===== BALANCE ===== */
.balance-panel {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.balance-panel.hidden {
  display: none;
}

.balance-label {
  font-size: 10px;
  letter-spacing: 0.2em;
  color: #b0b8c2;
}

.balance-pips {
  display: flex;
  gap: 4px;
}

.balance-pip {
  width: 8px;
  height: 8px;
  background: #3a3f45;
  border-radius: 1px;
}

.balance-pip.active {
  background: #9bb3c9;
}

.balance-pip.negative {
  background: #ff6a6a;
}

.balance-wobble {
  animation: balance-wobble 0.2s ease-out;
}

@keyframes balance-wobble {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  100% { transform: translateX(0); }
}

/* ===== RP (CHAIN BUILDER) ===== */
.rp-panel {
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.rp-panel.hidden {
  display: none;
}

.rp-label {
  font-size: 10px;
  letter-spacing: 0.2em;
  color: #b0b8c2;
}

.rp-pips {
  display: flex;
  gap: 4px;
}

.rp-pip {
  width: 8px;
  height: 8px;
  background: #3a3f45;
  border-radius: 1px;
}

.rp-pip.active {
  background: rgba(158, 43, 37, 0.9);
}

.rp-text {
  margin-left: auto;
  font-size: 11px;
  color: var(--dim);
}

  /* ===== Narration Container ===== */

    #narration-wrapper {
      position: relative;
      overflow: hidden;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }

    #narration {
      transition: opacity 0.4s ease, filter 0.4s ease;
    }

    /* ===== Fade / Smear States ===== */

    .fade-out {
      opacity: 0;
      filter: blur(6px) contrast(120%) saturate(120%);
    }

    .fade-in {
      opacity: 1;
      filter: blur(0);
    }

    /* ===== Vein Smear Overlay ===== */

    #narration-wrapper::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 30% 40%,
          rgba(140, 0, 0, 0.15),
          transparent 60%),
        radial-gradient(circle at 70% 60%,
          rgba(90, 0, 0, 0.12),
          transparent 65%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .smear-active::after {
      opacity: 1;
    }
  </style>
</head>

<body>

  <header>
    VEINBREAKER
  </header>

<div id="layout">
  <aside id="character-panel">
    <div class="vein-column">
      <div class="vein-node" id="hp-node">
        <span class="label">HP</span>
        <span class="value" id="char-hp">–</span>
      </div>

      <div class="vein-node" id="rp-node">
        <span class="label">RP</span>
        <span class="value" id="char-rp">–</span>
      </div>

      <div class="vein-node" id="veinscore-node">
        <span class="label">VEIN</span>
        <span class="value" id="char-veinscore">–</span>
      </div>
    </div>

    <div class="stats">
      <div>POW <span id="stat-str">–</span></div>
      <div>AGI <span id="stat-dex">–</span></div>
      <div>MND <span id="stat-int">–</span></div>
      <div>SPR <span id="stat-wil">–</span></div>
    </div>

    <!-- HEAT METER -->
    <div id="heat-container" class="heat-container">
      <div class="heat-label">HEAT</div>
      <div class="heat-bar">
        <div id="heat-fill" class="heat-fill"></div>
      </div>
      <div id="heat-value" class="heat-value">0</div>
    </div>

    <!-- MOMENTUM -->
    <div id="momentum-panel" class="momentum-panel">
      <div class="momentum-header">
        <span>MOMENTUM</span>
        <span id="momentum-value">0</span>
      </div>
      <div class="momentum-bar">
        <div id="momentum-fill"></div>
      </div>
    </div>

    <section id="abilities-panel">
      <div class="panel-title">ABILITIES</div>
      <div id="abilities-list"></div>
    </section>
  </aside>

  <main id="main">
    <!-- Enemy HUD card (stays visible during combat; not part of narration/log clearing) -->
    <section id="enemy-card" class="monster-card hidden" aria-live="polite">
      <div class="monster-top">
        <div class="monster-name" id="enemy-name">ENEMY</div>
        <div class="monster-meta" id="enemy-meta"></div>
        <div class="monster-badges">
          <span id="enemy-primed" class="enemy-badge hidden">PRIMED</span>
          <span id="enemy-bleed" class="enemy-badge bleed hidden">BLEED</span>
        </div>
      </div>

      <div class="monster-meters">
        <div class="meter-row">
          <div class="meter-label">HP</div>
          <div class="meter-bar hp"><div id="enemy-hp-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-hp-text">—</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">HEAT</div>
          <div class="meter-bar heat"><div id="enemy-heat-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-heat-text">0</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">MOM</div>
          <div class="meter-bar mom"><div id="enemy-mom-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-mom-text">0</div>
        </div>
        <div class="meter-row">
          <div class="meter-label">BAL</div>
          <div class="meter-bar bal"><div id="enemy-bal-fill" class="meter-fill"></div></div>
          <div class="meter-value" id="enemy-bal-text">0</div>
        </div>
      </div>
    </section>

    <div id="main-scroll">
      <div id="narration-wrapper">
        <div id="narration"></div>
      </div>
      <div id="log"></div>
    </div>

    <footer id="choices"></footer>
  </main>

  <aside id="combat-log-panel">
    <div id="combat-log-header" onclick="openSignals()">
      <span>COMBAT LOG</span>
      <span id="signal-dot" class="signal-dot hidden"></span>
    </div>
    <div id="signal-drawer" class="signal-drawer hidden">
      <div class="signal-drawer-header">
        SIGNALS
        <button onclick="closeSignals()">✕</button>
      </div>
      <div id="signal-list"></div>
    </div>
    <div id="combat-log"></div>
  </aside>
</div>

<!-- CHAIN OVERLAY (hidden until declare_chain event) -->
<div id="chain-overlay" class="hidden" aria-hidden="true">
  <div class="chain-modal">
    <div class="chain-title">
      <div class="chain-title-left">
        <div class="chain-h">DECLARE CHAIN</div>
        <div class="chain-sub" id="chain-sub">Select up to <span id="chain-max">6</span> links.</div>
      </div>
      <button class="chain-close" onclick="closeChainBuilder()">X</button>
    </div>

    <div class="chain-columns">
      <div class="ability-column">
        <h3>ATTACK</h3>
        <div id="attack-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>DEFENSE</h3>
        <div id="defense-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>UTILITY</h3>
        <div id="utility-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>MOVEMENT</h3>
        <div id="movement-abilities" class="ability-list"></div>
      </div>
    </div>

    <div class="chain-preview">
      <h3>CHAIN</h3>
      <div id="chain-slots"></div>

      <!-- BALANCE -->
      <div id="balance-panel" class="balance-panel hidden">
        <span class="balance-label">BALANCE</span>
        <div id="balance-pips" class="balance-pips"></div>
      </div>

      <!-- RP (shown during chain build) -->
      <div id="rp-panel" class="rp-panel hidden">
        <span class="rp-label">RP</span>
        <div id="rp-pips" class="rp-pips"></div>
        <div id="rp-text" class="rp-text">0/0</div>
      </div>

	      <div class="chain-actions">
	        <button id="chain-commit" onclick="submitChain()">COMMIT CHAIN</button>
	        <button id="chain-execute" class="secondary hidden" onclick="toggleExecute()">EXECUTE</button>
	        <button class="secondary" onclick="clearChain()">CLEAR</button>
	      </div>

      <div class="chain-hint" id="chain-hint">Tip: click a filled slot to remove it.</div>
    </div>
  </div>
</div>

<!-- INTERRUPT WINDOW -->
<div id="interrupt-window" class="interrupt hidden">
  <div class="interrupt-header">
    <span>INTERRUPT WINDOW</span>
    <span class="interrupt-timer" id="interrupt-timer">—</span>
  </div>

  <div id="interrupt-abilities" class="interrupt-list"></div>

  <div class="interrupt-footer">
    <button class="interrupt-skip" onclick="skipInterrupt()">ENDURE</button>
  </div>
</div>

<!-- EXECUTE WINDOW -->
<div id="execute-window" class="execute-window hidden" aria-live="polite">
  <div class="execute-header">
    <span>EXECUTION WINDOW</span>
  </div>
  <div id="execute-body" class="execute-body"></div>
  <div class="execute-footer">
    <button class="secondary" onclick="executeNo()">NO — LET IT BLEED</button>
    <button onclick="executeYes()">YES — TAKE THE MARK</button>
  </div>
</div>

<!-- INTERRUPTED OVERLAY -->
<div id="interrupt-overlay" class="interrupt-overlay hidden">
  <div class="interrupt-text">INTERRUPTED</div>
</div>

<!-- COMBAT RESULT OVERLAY -->
<div id="combat-result-overlay" class="result-overlay hidden">
  <div class="result-text" id="combat-result-text">VICTORY</div>
  <button class="result-continue" onclick="continueAfterCombat()">CONTINUE</button>
</div>

	<!-- LOOT OVERLAY -->
	<div id="loot-overlay" class="loot-overlay hidden" aria-hidden="true">
	  <div class="loot-modal">
    <div class="loot-title">
      <div class="loot-h">SPOILS</div>
      <div class="loot-sub" id="loot-sub">Claim what the Dungeon allows.</div>
    </div>

    <div id="loot-items" class="loot-items"></div>

    <div class="loot-actions">
      <button id="loot-take-all" onclick="takeAllLoot()">TAKE ALL</button>
      <button class="secondary" onclick="continueFromLoot()">CONTINUE</button>
    </div>
	  </div>
	</div>

	<!-- SAFE ROOM OVERLAY -->
	<div id="safe-room-overlay" class="safe-room-overlay hidden" aria-hidden="true">
	  <div class="safe-room-modal">
	    <div class="safe-room-header">
	      <div class="title">SAFE ROOM</div>
	      <div class="vein">VEIN <span id="safe-room-vein">0</span></div>
	    </div>

	    <div class="safe-room-body">
	      <div class="safe-room-character" id="safe-room-character"></div>

	      <section class="safe-room-progression">
	        <div class="panel-title">PROGRESSION</div>
	        <div id="safe-room-progression" class="safe-room-progression-text"></div>
	        <div id="safe-room-rest-result" class="safe-room-rest-result hidden"></div>
	      </section>

	      <section id="character-create-panel" class="character-create-panel hidden">
	        <div class="panel-title">NEW CHARACTER</div>
	        <div class="character-create-field">
	          <div class="label">NAME</div>
	          <input id="character-create-name" class="character-create-input" type="text" value="New Blood" />
	        </div>

	        <div class="panel-title">PATH</div>
	        <div id="character-create-paths" class="character-create-buttons"></div>

	        <div class="panel-title">RESOLVE ABILITY (PICK 1)</div>
	        <div id="character-create-rp" class="character-create-buttons"></div>
	      </section>

	      <section class="safe-room-shop">
	        <div class="panel-title">AVAILABLE UPGRADES</div>
	        <div id="safe-room-offers"></div>
	      </section>
	    </div>

	    <div class="safe-room-actions">
	      <button id="safe-room-rest" onclick="safeRoomRest()">STOP &amp; REST</button>
	      <button class="secondary" id="safe-room-continue" onclick="safeRoomContinue()">CONTINUE</button>
	    </div>
	  </div>
	</div>

	<!-- START MENU (slide-up) -->
	<div id="start-menu" class="start-menu hidden" aria-hidden="true">
	  <div class="start-sheet">
	    <div class="start-title">BEGIN</div>
	    <div class="start-sub">Choose how you enter the vein.</div>

	    <div class="start-actions">
	      <button onclick="startNewCharacter()">START NEW CHARACTER</button>
	      <button class="secondary" onclick="openLoadCharacter()">LOAD CHARACTER</button>
	      <button onclick="startWithDefault()">START WITH DEFAULT</button>
	    </div>

	    <div id="load-character-panel" class="load-character-panel hidden" aria-hidden="true">
	      <div class="panel-title">AVAILABLE PROFILES</div>
	      <div id="character-list"></div>
	      <div class="load-actions">
	        <button class="secondary" onclick="closeLoadCharacter()">BACK</button>
	      </div>
	    </div>
	  </div>
	</div>

	<script>
	const API = "http://localhost:8000/step"; // adjust if needed
	const EVENTS_API = "http://localhost:8000/events";
	const CHARACTER_API = "http://localhost:8000/character";
	const CHARACTERS_API = "http://localhost:8000/characters";
	const SELECT_CHARACTER_API = "http://localhost:8000/character/select";
	const sessionId = crypto.randomUUID();
	document.body.classList.add("chain-pulse");

const log = document.getElementById("log");
const combatLog = document.getElementById("combat-log");
const signalDot = document.getElementById("signal-dot");
const narrationWrapper = document.getElementById("narration-wrapper");
const narrationEl = document.getElementById("narration");
const mainScroll = document.getElementById("main-scroll");
const choicesEl = document.getElementById("choices");
const charHp = document.getElementById("char-hp");
const charRp = document.getElementById("char-rp");
    const charVeinscore = document.getElementById("char-veinscore");
    const statStr = document.getElementById("stat-str");
const statDex = document.getElementById("stat-dex");
const statInt = document.getElementById("stat-int");
const statWil = document.getElementById("stat-wil");
let signals = [];
let hasUnreadSignals = false;
let characterState = null;
let enemyState = null;
let abilityById = new Map();
let pendingCombatResult = null;
let combatResultDelayUntil = 0;
let combatResultDelayTimer = null;
const HEAT_CAP = 8;
const MOMENTUM_MAX = 8;

function addEntry(text, cls) {
  const div = document.createElement("div");
  div.className = `entry ${cls}`;
  div.textContent = text;
  log.appendChild(div);
  if (mainScroll) {
    mainScroll.scrollTop = mainScroll.scrollHeight;
  }
}

function clearChoices() {
  choicesEl.innerHTML = "";
}

async function sendStep(payload) {
  try {
    const body = { session_id: sessionId, ...payload };
    console.debug("[sendStep]", body);

    const res = await fetch(API, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(body)
    });

    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status} ${res.statusText} ${text}`.trim());
    }

    const events = await res.json();
    handleEvents(events);
    return events;
  } catch (err) {
    console.error("sendStep failed", err);
    addEntry(`sendStep failed: ${err?.message || err}`, "error");
    return [];
  }
}

async function sendChoice(index) {
  clearChoices();
  await sendStep({ choice: index });
}

function openSafeRoomScreen(ev) {
  const overlay = document.getElementById("safe-room-overlay");
  const veinEl = document.getElementById("safe-room-vein");
  const chEl = document.getElementById("safe-room-character");
  const progEl = document.getElementById("safe-room-progression");
  const restEl = document.getElementById("safe-room-rest-result");
  const offersEl = document.getElementById("safe-room-offers");
  if (!overlay || !veinEl || !chEl || !offersEl || !progEl || !restEl) return;

  // Ensure other overlays don't steal focus.
  closeChainBuilder();
  clearChoices();

  window.__safeRoomMode = ev?.mode || "safe_room";
  window.__characterCreateStage = ev?.stage || null;

  const veinscore = Number(ev?.character?.veinscore ?? 0);
  veinEl.textContent = String(veinscore);

  const cname = ev?.character?.name ?? "—";
  const ctier = ev?.character?.tier ?? "—";
  chEl.textContent = `${cname} · Tier ${ctier}`;

  const spent = Number(ev?.character?.veins_spent_total ?? ev?.progression?.veins_spent_total ?? 0);
  const nextTier = ev?.progression?.next_tier ?? null;
  const nextAt = ev?.progression?.next_unlock_at ?? null;
  const remaining = ev?.progression?.remaining ?? null;
  if (nextTier && nextAt != null) {
    progEl.textContent = `Vein spent total: ${spent} · Next tier (T${nextTier}) unlocks at ${nextAt} (need ${remaining}).`;
  } else {
    progEl.textContent = `Vein spent total: ${spent} · Max tier unlocked.`;
  }

  const rest = ev?.rest_result ?? null;
  if (rest && rest.hp && rest.rp) {
    const hp = rest.hp;
    const rp = rest.rp;
    const pools = rest.pools || {};
    const poolBits = Object.keys(pools).map(k => `${k} ${pools[k].before}→${pools[k].after}`).join(" · ");
    restEl.textContent = `REST RESULTS — HP ${hp.before}→${hp.after}/${hp.max} · RP ${rp.before}→${rp.after}/${rp.cap}` + (poolBits ? ` · ${poolBits}` : "");
    restEl.classList.remove("hidden");
  } else {
    restEl.classList.add("hidden");
  restEl.textContent = "";
  }

  offersEl.innerHTML = "";
  const offers = ev?.shop?.offers || [];
  offers.forEach(off => {
    const div = document.createElement("div");
    div.className = "safe-room-offer";
    const cost = Number(off.cost ?? 1);
    const canAfford = veinscore >= cost;

    div.innerHTML = `
      <div class="row">
        <div class="name">${off.name}</div>
        <div class="meta">T${off.tier ?? "?"} · ${off.path ?? ""} · COST ${cost}</div>
      </div>
      ${off.effect ? `<div class="desc">${off.effect}</div>` : ""}
      <button ${canAfford ? "" : "disabled"}>BUY</button>
    `;

    const btn = div.querySelector("button");
    if (btn) {
      const act = (window.__safeRoomMode === "character_create") ? "character_create_buy" : "safe_room_buy";
      btn.onclick = () => sendStep({ action: act, ability: off.id });
    }
    offersEl.appendChild(div);
  });

  // Character creation extras (reuses the safe room overlay).
  const cc = document.getElementById("character-create-panel");
  const nameInput = document.getElementById("character-create-name");
  const pathsEl = document.getElementById("character-create-paths");
  const rpEl = document.getElementById("character-create-rp");
  const restBtn = document.getElementById("safe-room-rest");
  const contBtn = document.getElementById("safe-room-continue");

  if (cc && nameInput && pathsEl && rpEl && restBtn && contBtn) {
    const isCC = window.__safeRoomMode === "character_create";
    cc.classList.toggle("hidden", !isCC);

    if (isCC) {
      // Re-label buttons for creation.
      restBtn.classList.add("hidden");
      contBtn.textContent = "BEGIN";

      nameInput.value = String(ev?.character?.name ?? "New Blood");

      const stage = window.__characterCreateStage || "choose_path";
      const create = ev?.create || {};
      const paths = create.paths || [];
      const rps = create.rp_abilities || [];

      pathsEl.innerHTML = "";
      rpEl.innerHTML = "";

      paths.forEach(p => {
        const b = document.createElement("button");
        b.className = "choice";
        b.textContent = p.label || p.id;
        b.onclick = () => sendStep({ action: "character_create_path", path: p.id });
        pathsEl.appendChild(b);
      });

      if (stage === "choose_rp" || stage === "shop") {
        rps.forEach(a => {
          const b = document.createElement("button");
          b.className = "choice secondary";
          b.textContent = a.name || a.id;
          b.onclick = () => sendStep({ action: "character_create_rp", rp_ability: a.id });
          rpEl.appendChild(b);
        });
      }

      contBtn.disabled = stage !== "shop";
      contBtn.onclick = async () => {
        const nm = String(nameInput.value || "").trim();
        await sendStep({ action: "character_create_finish", name: nm });
        closeSafeRoomScreen();
      };
    } else {
      restBtn.classList.remove("hidden");
      contBtn.disabled = false;
      contBtn.textContent = "CONTINUE";
    }
  }

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
}

function closeSafeRoomScreen() {
  const overlay = document.getElementById("safe-room-overlay");
  if (!overlay) return;
  overlay.classList.add("hidden");
  overlay.setAttribute("aria-hidden", "true");
}

async function safeRoomRest() {
  const mode = window.__safeRoomMode || "safe_room";
  if (mode === "safe_room") {
    await sendStep({ action: "safe_room_rest" });
  }
}

async function safeRoomContinue() {
  closeSafeRoomScreen();
  const mode = window.__safeRoomMode || "safe_room";
  if (mode === "safe_room") {
    await sendStep({ action: "safe_room_continue" });
  }
}

function openStartMenu() {
  const menu = document.getElementById("start-menu");
  if (!menu) return;
  menu.classList.remove("hidden");
  menu.setAttribute("aria-hidden", "false");
  requestAnimationFrame(() => menu.classList.add("active"));
}

function closeStartMenu() {
  const menu = document.getElementById("start-menu");
  if (!menu) return;
  menu.classList.remove("active");
  setTimeout(() => {
    menu.classList.add("hidden");
    menu.setAttribute("aria-hidden", "true");
  }, 220);
}

async function startNewCharacter() {
  closeStartMenu();
  await sendStep({ action: "new_character_begin" });
}

async function openLoadCharacter() {
  const panel = document.getElementById("load-character-panel");
  const list = document.getElementById("character-list");
  if (!panel || !list) return;
  panel.classList.remove("hidden");
  panel.setAttribute("aria-hidden", "false");
  list.innerHTML = "Loading...";

  try {
    const res = await fetch(CHARACTERS_API);
    const chars = await res.json();
    list.innerHTML = "";

    (chars || []).forEach(c => {
      const row = document.createElement("div");
      row.className = "character-row";
      row.innerHTML = `
        <div class="name">${c.name ?? c.id}</div>
        <div class="meta">${c.path ?? ""} · T${c.tier ?? "?"}</div>
      `;
      row.onclick = async () => {
        await fetch(SELECT_CHARACTER_API, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ character_id: c.id })
        });
        await startGame();
      };
      list.appendChild(row);
    });

    if (!chars || !chars.length) {
      list.innerHTML = "<div class='entry system'>No profiles found.</div>";
    }
  } catch (e) {
    console.error("load characters failed", e);
    list.innerHTML = "<div class='entry error'>Failed to load profiles.</div>";
  }
}

function closeLoadCharacter() {
  const panel = document.getElementById("load-character-panel");
  if (!panel) return;
  panel.classList.add("hidden");
  panel.setAttribute("aria-hidden", "true");
}

async function startWithDefault() {
  await startGame();
}

async function startGame() {
  closeLoadCharacter();
  closeStartMenu();

  // Kick the backend session.
  await sendStep({ action: "start" });

  // Seed the character panel catalog from /character (abilities + ids).
  try {
    const res = await fetch(CHARACTER_API);
    const ch = await res.json();
    characterState = ch;
    abilityById = new Map();
    if (Array.isArray(ch?.abilities)) {
      ch.abilities.forEach(ab => {
        if (!ab) return;
        const id = ab.id || ab.name;
        if (!id) return;
        abilityById.set(id, { ...ab, id });
      });
    }
    updateCharacterUI(characterState);
    renderAbilitiesPanel(characterState);
  } catch (e) {
    console.error("Failed to fetch /character", e);
  }
}

async function loadIntroText() {
  try {
    const res = await fetch("ui/introtext.md");
    if (!res.ok) return;
    const md = await res.text();
    const blocks = md.split(/\r?\n\r?\n/).map(s => s.trim()).filter(Boolean);
    blocks.forEach(b => appendNarration(b));
  } catch {
    // ignore
  }
}

function clearNarration() {
  narrationEl.classList.add("fade-out");
  narrationWrapper.classList.add("smear-active");

  setTimeout(() => {
    narrationEl.innerHTML = "";
    narrationEl.classList.remove("fade-out");
    narrationEl.classList.add("fade-in");
    narrationWrapper.classList.remove("smear-active");
    setTimeout(() => narrationEl.classList.remove("fade-in"), 400);
  }, 400);
}

function appendNarration(text) {
  const p = document.createElement("p");
  p.textContent = text;
  p.style.opacity = "0";
  p.style.transition = "opacity 0.3s ease";
  narrationEl.appendChild(p);
  requestAnimationFrame(() => {
    p.style.opacity = "1";
  });
  if (mainScroll) {
    mainScroll.scrollTop = mainScroll.scrollHeight;
  }
}

function appendCombatLog(text) {
  logCombat(text);
}

function logCombat(text, type = "system") {
  const div = document.createElement("div");
  div.className = `log-entry ${type}`;
  div.textContent = text;
  combatLog.prepend(div);
  combatLog.scrollTop = 0;
}

function addSignal(type, text) {
  signals.unshift({ type, text });
  hasUnreadSignals = true;
  signalDot.classList.remove("hidden");
  renderSignals();
}

function renderSignals() {
  const host = document.getElementById("signal-list");
  host.innerHTML = "";

  signals.forEach(s => {
    const div = document.createElement("div");
    div.className = "signal";
    div.innerHTML = `<strong>${(s.type || "SYSTEM").toUpperCase()}</strong><br>${s.text}`;
    host.appendChild(div);
  });
}

function openSignals() {
  document.getElementById("signal-drawer").classList.remove("hidden");
  hasUnreadSignals = false;
  signalDot.classList.add("hidden");
}

function closeSignals() {
  document.getElementById("signal-drawer").classList.add("hidden");
}

function setCombatActive(active) {
  const card = document.getElementById("enemy-card");
  if (!card) return;
  if (active) {
    card.classList.remove("hidden");
  } else {
    card.classList.add("hidden");
  }
}

function flashInterrupt() {
  triggerInterruptFlash();
}

function triggerInterruptFlash() {
  document.body.classList.add("interrupt-flash");
  setTimeout(() => {
    document.body.classList.remove("interrupt-flash");
  }, 180);
}

function showInterruptOverlay(duration = 1500, text = "INTERRUPTED") {
  const overlay = document.getElementById("interrupt-overlay");
  if (!overlay) return;

  const textEl = overlay.querySelector(".interrupt-text");
  if (textEl && text) {
    textEl.textContent = text;
  }

  overlay.classList.remove("hidden");
  overlay.offsetHeight; // force reflow so transition fires
  overlay.classList.add("active");

  setTimeout(() => {
    overlay.classList.remove("active");
    setTimeout(() => overlay.classList.add("hidden"), 200);
  }, duration);
}

// INTERRUPT WINDOW UI
let interruptTimeout = null;
let interruptResizeBound = false;

function positionInterruptWindow() {
  const win = document.getElementById("interrupt-window");
  const main = document.getElementById("main");
  if (!win || !main) return;

  const rect = main.getBoundingClientRect();
  win.style.left = `${Math.round(rect.left)}px`;
  win.style.width = `${Math.round(rect.width)}px`;
  win.style.right = "auto";
}

function bindInterruptResize() {
  if (interruptResizeBound) return;
  interruptResizeBound = true;
  window.addEventListener("resize", () => {
    const win = document.getElementById("interrupt-window");
    if (!win) return;
    if (!win.classList.contains("hidden")) {
      positionInterruptWindow();
    }
  });
}

function openInterruptWindow(abilities, seconds = null) {
  clearChoices();
  try { closeChainBuilder(); } catch (e) { /* ignore */ }
  const win = document.getElementById("interrupt-window");
  const host = document.getElementById("interrupt-abilities");
  const timer = document.getElementById("interrupt-timer");

  if (!win || !host || !timer) {
    console.warn("interrupt_window: missing DOM nodes", { win, host, timer });
    return;
  }

  bindInterruptResize();
  positionInterruptWindow();

  host.innerHTML = "";
  const sec = (seconds === undefined || seconds === null) ? null : Number(seconds);
  timer.textContent = (sec && sec > 0) ? `${sec}s` : "—";

  (abilities || []).forEach(ab => {
    const card = document.createElement("div");
    card.className = "ability-card";

    card.innerHTML = `
      <div class="row">
        <div class="name">${ab.name}</div>
        <div class="meta">${ab.cost ?? 0} RP</div>
      </div>
      <div class="desc">${ab.effect ?? ""}</div>
    `;

    card.onclick = async () => {
      closeInterruptWindow();
      await sendStep({ action: "interrupt", ability: ab.id });
    };

    host.appendChild(card);
  });

  win.classList.remove("hidden");
  // Make it visible immediately; RAF just ensures transitions fire.
  win.classList.add("active");
  requestAnimationFrame(() => win.classList.add("active"));

  clearTimeout(interruptTimeout);
  interruptTimeout = null;
  // Do not auto-dismiss; the player must explicitly Endure or pick an interrupt ability.
}

function closeInterruptWindow() {
  const win = document.getElementById("interrupt-window");
  if (!win) return;
  win.classList.remove("active");
  setTimeout(() => win.classList.add("hidden"), 220);
  win.style.left = "";
  win.style.right = "";
  win.style.width = "";
}

async function skipInterrupt() {
  closeInterruptWindow();
  await sendStep({ action: "interrupt_skip" });
}

// EXECUTE WINDOW UI
let executeResizeBound = false;

function positionExecuteWindow() {
  const win = document.getElementById("execute-window");
  const main = document.getElementById("main");
  if (!win || !main) return;
  const rect = main.getBoundingClientRect();
  win.style.left = `${Math.round(rect.left)}px`;
  win.style.width = `${Math.round(rect.width)}px`;
  win.style.right = "auto";
}

function bindExecuteResize() {
  if (executeResizeBound) return;
  executeResizeBound = true;
  window.addEventListener("resize", () => {
    const win = document.getElementById("execute-window");
    if (!win) return;
    if (!win.classList.contains("hidden")) {
      positionExecuteWindow();
    }
  });
}

function openExecuteWindow(text, enemyName) {
  clearChoices();
  try { closeChainBuilder(); } catch (e) { /* ignore */ }

  const win = document.getElementById("execute-window");
  const body = document.getElementById("execute-body");
  if (!win || !body) return;

  bindExecuteResize();
  positionExecuteWindow();
  try { flashInterrupt(); } catch (e) { /* ignore */ }

  const who = enemyName ? String(enemyName) : "The target";
  body.textContent = text || `${who} is primed. Execute?`;

  win.classList.remove("hidden");
  win.classList.add("active");
  requestAnimationFrame(() => win.classList.add("active"));
}

function closeExecuteWindow() {
  const win = document.getElementById("execute-window");
  if (!win) return;
  win.classList.remove("active");
  setTimeout(() => win.classList.add("hidden"), 220);
  win.style.left = "";
  win.style.right = "";
  win.style.width = "";
}

async function executeYes() {
  closeExecuteWindow();
  await sendStep({ action: "execute_yes" });
}

async function executeNo() {
  closeExecuteWindow();
  await sendStep({ action: "execute_no" });
}

function showCombatResult(result) {
  const overlay = document.getElementById("combat-result-overlay");
  const text = document.getElementById("combat-result-text");
  if (!overlay || !text) return;

  const r = (result || "").toLowerCase();
  window.__lastCombatResult = r;
  if (r === "defeat") {
    text.textContent = "BLOOD MARK (DUN)";
    overlay.classList.add("defeat");
    const btn = overlay.querySelector(".result-continue");
    if (btn) btn.textContent = "RE-AWAKEN";
  } else {
    text.textContent = "VICTORY";
    overlay.classList.remove("defeat");
    const btn = overlay.querySelector(".result-continue");
    if (btn) btn.textContent = "CONTINUE";
  }

  overlay.classList.remove("hidden");
  overlay.offsetHeight;
  overlay.classList.add("active");
}

function applyEnemyUpdate(delta) {
  if (!delta) return;
  enemyState = { ...(enemyState || {}), ...delta };
  renderEnemyCard(enemyState);
}

function renderEnemyCard(enemy) {
  const card = document.getElementById("enemy-card");
  if (!card) return;
  card.classList.remove("hidden");

  const nameEl = document.getElementById("enemy-name");
  const metaEl = document.getElementById("enemy-meta");
  const primedEl = document.getElementById("enemy-primed");
  const bleedEl = document.getElementById("enemy-bleed");
  if (nameEl) nameEl.textContent = (enemy.name || "ENEMY").toUpperCase();

  const parts = [];
  if (enemy.tier !== undefined && enemy.tier !== null) parts.push(`T${enemy.tier}`);
  if (enemy.role) parts.push(String(enemy.role).toUpperCase());
  if (enemy.dv_base !== undefined && enemy.dv_base !== null) parts.push(`DV ${enemy.dv_base}`);
  if (enemy.idf !== undefined && enemy.idf !== null) parts.push(`IDF ${enemy.idf}`);
  if (metaEl) metaEl.textContent = parts.join(" · ");
  if (primedEl) primedEl.classList.toggle("hidden", !enemy.primed);

  // Status badges (separate from PRIMED)
  try {
    const statuses = enemy.statuses || {};
    const bleed = statuses?.bleed;
    const stacks = Number((bleed && bleed.stacks !== undefined) ? bleed.stacks : bleed) || 0;
    const dur = Number((bleed && bleed.duration !== undefined) ? bleed.duration : 0) || 0;
    if (bleedEl) {
      if (stacks > 0) {
        bleedEl.textContent = dur > 0 ? `BLEED ${stacks} (${dur})` : `BLEED ${stacks}`;
        bleedEl.classList.remove("hidden");
      } else {
        bleedEl.classList.add("hidden");
      }
    }
  } catch (e) {
    if (bleedEl) bleedEl.classList.add("hidden");
  }

  const hp = enemy.hp || {};
  const hpCur = Number(hp.current ?? hp.hp ?? 0);
  const hpMax = Number(hp.max ?? hp.max_hp ?? hpCur ?? 1);
  const hpPct = hpMax > 0 ? Math.max(0, Math.min(100, (hpCur / hpMax) * 100)) : 0;

  const hpFill = document.getElementById("enemy-hp-fill");
  const hpText = document.getElementById("enemy-hp-text");
  if (hpFill) hpFill.style.width = `${hpPct}%`;
  if (hpText) hpText.textContent = `${hpCur}/${hpMax}`;

  const heat = Number(enemy.heat ?? 0);
  const momentum = Number(enemy.momentum ?? 0);
  const balance = Number(enemy.balance ?? 0);

  const heatFill = document.getElementById("enemy-heat-fill");
  const heatText = document.getElementById("enemy-heat-text");
  if (heatFill) heatFill.style.width = `${Math.max(0, Math.min(100, (heat / HEAT_CAP) * 100))}%`;
  if (heatText) heatText.textContent = String(heat);

  const momFill = document.getElementById("enemy-mom-fill");
  const momText = document.getElementById("enemy-mom-text");
  if (momFill) momFill.style.width = `${Math.max(0, Math.min(100, (momentum / MOMENTUM_MAX) * 100))}%`;
  if (momText) momText.textContent = String(momentum);

  const BAL_CAP = 10;
  const balAbs = Math.min(BAL_CAP, Math.abs(balance));
  const balFill = document.getElementById("enemy-bal-fill");
  const balText = document.getElementById("enemy-bal-text");
  if (balFill) {
    balFill.style.width = `${Math.max(0, Math.min(100, (balAbs / BAL_CAP) * 100))}%`;
    balFill.style.background = balance < 0 ? "rgba(229, 75, 75, 0.9)" : "rgba(155, 179, 201, 0.85)";
  }
  if (balText) balText.textContent = String(balance);
}

async function continueAfterCombat() {
  const overlay = document.getElementById("combat-result-overlay");
  if (overlay) {
    overlay.classList.remove("active");
    setTimeout(() => overlay.classList.add("hidden"), 200);
  }
  const r = (window.__lastCombatResult || "").toLowerCase();
  if (r === "defeat") {
    await sendStep({ action: "defeat_continue" });
  } else {
    await sendStep({ action: "combat_loot" });
  }
}

function openLootScreen(items, summaryText) {
  clearChoices();
  try { closeChainBuilder(); } catch (e) { /* ignore */ }
  try { closeInterruptWindow(); } catch (e) { /* ignore */ }

  const overlay = document.getElementById("loot-overlay");
  const host = document.getElementById("loot-items");
  const sub = document.getElementById("loot-sub");
  if (!overlay || !host || !sub) return;

  host.innerHTML = "";
  sub.textContent = summaryText || "Claim what the Dungeon allows.";

  (items || []).forEach(it => {
    const row = document.createElement("div");
    row.className = "loot-item";
    const rarity = (it.rarity || "common").toUpperCase();
    const desc = it.description || it.narration || "";
    row.innerHTML = `
      <div class="loot-item-top">
        <div class="loot-item-name">${it.name || it.id || "Unknown"}</div>
        <div class="loot-item-rarity">${rarity}</div>
      </div>
      ${desc ? `<div class="loot-item-desc">${desc}</div>` : ""}
    `;
    host.appendChild(row);
  });

  overlay.classList.remove("hidden");
  overlay.setAttribute("aria-hidden", "false");
  overlay.offsetHeight;
  overlay.classList.add("active");
}

function closeLootScreen() {
  const overlay = document.getElementById("loot-overlay");
  if (!overlay) return;
  overlay.classList.remove("active");
  setTimeout(() => {
    overlay.classList.add("hidden");
    overlay.setAttribute("aria-hidden", "true");
  }, 200);
}

async function takeAllLoot() {
  await sendStep({ action: "loot_take_all" });
}

async function continueFromLoot() {
  closeLootScreen();
  await sendStep({ action: "loot_continue" });
}

function updateCharacterUI(char) {
  if (!char) return;
  if (char.hp) {
    const cur = char.hp.current ?? char.hp;
    const max = char.hp.max ?? char.hp_max ?? cur;
    charHp.textContent = `${cur}/${max}`;
  }
  if (char.rp !== undefined) {
    const rpCur = (typeof char.rp === "object" && char.rp) ? (char.rp.current ?? 0) : char.rp;
    const rpCap = (typeof char.rp === "object" && char.rp) ? char.rp.cap : undefined;
    charRp.textContent = (rpCap !== undefined && rpCap !== null) ? `${rpCur}/${rpCap}` : String(rpCur);
  }
  if (char.veinscore !== undefined) {
    charVeinscore.textContent = char.veinscore;
  }
  if (char.attributes) {
    statStr.textContent = char.attributes.str ?? "—";
    statDex.textContent = char.attributes.dex ?? "—";
    statInt.textContent = char.attributes.int ?? "—";
    statWil.textContent = char.attributes.wil ?? "—";
  }
  renderAbilitiesPanel(char);
}

function updateHeat(value) {
  const fill = document.getElementById("heat-fill");
  const val = document.getElementById("heat-value");
  const container = document.getElementById("heat-container");
  if (!fill || !val || !container) return;

  const clamped = Math.max(0, Math.min(Number(value ?? 0), HEAT_CAP));
  const pct = (clamped / HEAT_CAP) * 100;
  fill.style.width = pct + "%";
  val.textContent = String(clamped);

  if (clamped >= 5) container.classList.add("high");
  else container.classList.remove("high");
}

function updateMomentum(value, shocked = false) {
  const panel = document.getElementById("momentum-panel");
  const fill = document.getElementById("momentum-fill");
  const label = document.getElementById("momentum-value");
  if (!panel || !fill || !label) return;

  const clamped = Math.max(0, Math.min(MOMENTUM_MAX, Number(value ?? 0)));
  const pct = (clamped / MOMENTUM_MAX) * 100;

  label.textContent = String(clamped);
  fill.style.width = `${pct}%`;

  if (shocked) {
    panel.classList.add("momentum-shock");
    setTimeout(() => panel.classList.remove("momentum-shock"), 300);
  }
}

function updateBalance(value) {
  const panel = document.getElementById("balance-panel");
  const host = document.getElementById("balance-pips");
  if (!panel || !host) return;

  host.innerHTML = "";
  panel.classList.remove("hidden");

  const v = Number(value ?? 0);
  const abs = Math.abs(v);
  for (let i = 0; i < abs; i++) {
    const pip = document.createElement("div");
    pip.className = "balance-pip";
    if (v > 0) pip.classList.add("active");
    if (v < 0) pip.classList.add("negative");
    host.appendChild(pip);
  }
}

function wobbleBalance() {
  const panel = document.getElementById("balance-panel");
  if (!panel) return;
  panel.classList.add("balance-wobble");
  setTimeout(() => panel.classList.remove("balance-wobble"), 200);
}

function clearBalance() {
  const panel = document.getElementById("balance-panel");
  if (!panel) return;
  panel.classList.add("hidden");
}

function updateRPPanel() {
  const panel = document.getElementById("rp-panel");
  const host = document.getElementById("rp-pips");
  const text = document.getElementById("rp-text");
  if (!panel || !host || !text) return;

  const rp = characterState?.rp;
  const cur = (typeof rp === "object" && rp) ? Number(rp.current ?? 0) : Number(rp ?? 0);
  const cap = (typeof rp === "object" && rp) ? Number(rp.cap ?? cur) : Number(cur);

  host.innerHTML = "";
  panel.classList.remove("hidden");
  text.textContent = `${cur}/${cap}`;

  const total = Math.max(0, Math.min(12, cap)); // keep it sane visually
  for (let i = 0; i < total; i++) {
    const pip = document.createElement("div");
    pip.className = "rp-pip";
    if (i < cur) pip.classList.add("active");
    host.appendChild(pip);
  }
}

function clearRPPanel() {
  const panel = document.getElementById("rp-panel");
  if (!panel) return;
  panel.classList.add("hidden");
}

function renderAbilitiesPanel(character) {
  const host = document.getElementById("abilities-list");
  host.innerHTML = "";

  if (!character?.abilities) return;

  character.abilities.forEach(ab => {
    const row = document.createElement("div");
    row.className = "ability-row";

    if (ab.cooldown && ab.cooldown > 0) {
      row.classList.add("cooldown");
    }

    const tags = (ab.tags || []).join(" · ");

    row.innerHTML = `
      <div class="top">
        <div class="name">${ab.name}</div>
        <div class="meta">
          ${ab.cost ? `${ab.cost} RP` : ""}
          ${ab.cooldown ? ` · CD ${ab.cooldown}` : ""}
        </div>
      </div>
      <div class="tags">
        ${ab.tier ? `T${ab.tier} · ` : ""}${tags}
      </div>
    `;

    host.appendChild(row);
  });
}

function renderChoices(prompt, options) {
  clearChoices();

  const p = document.createElement("div");
  p.className = "prompt";
  p.textContent = prompt;
  choicesEl.appendChild(p);

  options.forEach((opt, i) => {
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = `${i + 1}. ${opt}`;
    btn.onclick = () => sendChoice(i);
    choicesEl.appendChild(btn);
  });
}

function handleEvents(events) {
  events.forEach(ev => {
    switch (ev.type) {
      case "clear":
        if (ev.target === "narration" || ev.target === "all") {
          clearNarration();
        }
        if (ev.target === "choices" || ev.target === "all") {
          clearChoices();
        }
        if (ev.target === "log" || ev.target === "all") {
          log.innerHTML = "";
        }
        break;
      case "scene":
        appendNarration(ev.text);
        break;
      case "narration":
        appendNarration(ev.text);
        break;
      case "character_update":
        applyCharacterUpdate(ev.character);
        break;
      case "resource_update":
      case "resources_update":
        if (!characterState) characterState = {};
        if (!characterState.meters) characterState.meters = {};
        if (ev.heat !== undefined) updateHeat(ev.heat);
        if (ev.momentum !== undefined) updateMomentum(ev.momentum, !!ev.shocked);
        if (ev.balance !== undefined) updateBalance(ev.balance);
        if (ev.heat !== undefined) characterState.meters.heat = Number(ev.heat);
        if (ev.momentum !== undefined) characterState.meters.momentum = Number(ev.momentum);
        if (ev.balance !== undefined) characterState.meters.balance = Number(ev.balance);
        break;
      case "balance_update":
        if (ev.balance !== undefined) updateBalance(ev.balance);
        if (ev.wobble) wobbleBalance();
        break;
      case "chain_end":
        clearBalance();
        break;
      case "loot":
        addEntry(ev.text, "loot");
        break;
      case "system":
        addEntry(ev.text, "system");
        break;
      case "log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_state":
        setCombatActive(!!ev.active);
        break;
      case "enemy_update":
        applyEnemyUpdate(ev.enemy);
        break;
      case "safe_room_enter":
        openSafeRoomScreen(ev);
        break;
      case "combat_result":
        {
          const r = String(ev.result || "").toLowerCase();
          const now = Date.now();
          const delayActive = r !== "defeat" && combatResultDelayUntil && now < combatResultDelayUntil;

          if (delayActive) {
            pendingCombatResult = ev.result;
            if (combatResultDelayTimer) clearTimeout(combatResultDelayTimer);
            combatResultDelayTimer = setTimeout(() => {
              showCombatResult(pendingCombatResult);
              pendingCombatResult = null;
              combatResultDelayUntil = 0;
              combatResultDelayTimer = null;
            }, Math.max(0, combatResultDelayUntil - Date.now()));
          } else {
            showCombatResult(ev.result);
          }
        }
        break;
      case "loot_screen":
        openLootScreen(ev.items || [], ev.summary);
        break;
      case "interrupt":
        flashInterrupt();
        if (ev.text) {
          logCombat(ev.text, "interrupt");
        }
        break;
      case "chain_interrupted":
        {
          const msg = ev.text || "Chain interrupted!";
          // If the enemy chain was interrupted (player countered), use a shorter label.
          const label = msg.toLowerCase().includes("enemy chain") ? "COUNTERED" : "INTERRUPTED";
          showInterruptOverlay(1500, label);
          logCombat(msg, "interrupt");
        }
        break;
      case "interrupt_window":
        flashInterrupt();
        openInterruptWindow(ev.abilities, ev.timeout ?? null);
        break;
      case "execute_window":
        openExecuteWindow(ev.text, ev.enemy);
        break;
      case "execution_failed":
        {
          const label = ev.catastrophic ? "EXECUTION SHATTERED" : "EXECUTION FAILED";
          showInterruptOverlay(1800, label);
          logCombat(ev.text || label, "damage");
        }
        break;
      case "enemy_executed":
        {
          const label = ev.enemy ? `${String(ev.enemy).toUpperCase()} EXECUTED` : (ev.text || "ENEMY EXECUTED");
          showInterruptOverlay(1000, label);
          combatResultDelayUntil = Date.now() + 1000;

          if (pendingCombatResult) {
            if (combatResultDelayTimer) clearTimeout(combatResultDelayTimer);
            combatResultDelayTimer = setTimeout(() => {
              showCombatResult(pendingCombatResult);
              pendingCombatResult = null;
              combatResultDelayUntil = 0;
              combatResultDelayTimer = null;
            }, 1000);
          }
        }
        break;
      case "execution_available":
        executionAvailable = true;
        updateExecuteUI();
        break;
      case "visceral_attack":
        {
          const label = "VISCERAL ATTACK";
          showInterruptOverlay(3800, label);
          if (ev.text) logCombat(ev.text, "attack");
        }
        break;
      case "declare_chain":
        chainAbilities = ev.abilities || [];
        maxChainLength = Math.max(ev.maxLength ?? 6, 6);
        const maxEl = document.getElementById("chain-max");
        if (maxEl) {
          maxEl.textContent = String(maxChainLength);
        }
        chain = [];
        executionAvailable = false;
        executionRequested = false;
        updateExecuteUI();
        renderAbilities(chainAbilities);
        renderChain();
        renderChainRules(ev.chainRules);
        renderChainHint(ev.chainRules);
        openChainBuilder();
        break;
      case "signal":
        addSignal(ev.signalType || "system", ev.text);
        break;
      case "chain_rejected":
        rejectChain(ev.reason);
        break;
      case "choice":
        renderChoices(ev.prompt, ev.options);
        break;
    }
  });
}

function applyCharacterUpdate(delta) {
  if (!delta) return;
  if (!characterState) {
    characterState = { abilities: [] };
  }
  if (delta.name !== undefined) characterState.name = delta.name;
  if (delta.hp !== undefined) characterState.hp = delta.hp;
  if (delta.rp !== undefined) characterState.rp = delta.rp;
  if (delta.veinscore !== undefined) characterState.veinscore = delta.veinscore;
  if (delta.meters && typeof delta.meters === "object") {
    characterState.meters = { ...(characterState.meters || {}), ...delta.meters };
    if (delta.meters.heat !== undefined) updateHeat(delta.meters.heat);
    if (delta.meters.momentum !== undefined) updateMomentum(delta.meters.momentum);
    if (delta.meters.balance !== undefined) updateBalance(delta.meters.balance);
  }

  if (Array.isArray(delta.abilities)) {
    delta.abilities.forEach(a => {
      if (!a || !a.id) return;
      const existing = abilityById.get(a.id) || { id: a.id, name: a.id };
      if (a.cooldown !== undefined) existing.cooldown = a.cooldown;
      abilityById.set(a.id, existing);
    });
    characterState.abilities = Array.from(abilityById.values());
  }

  updateCharacterUI(characterState);
  renderAbilitiesPanel(characterState);
  updateRPPanel();
}

// initial boot: show intro + start menu (do not start the backend yet)
loadIntroText().finally(() => {
  openStartMenu();
});

async function pollEvents() {
  try {
    const res = await fetch(EVENTS_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ session_id: sessionId })
    });

    const events = await res.json();
    if (Array.isArray(events) && events.length) {
      handleEvents(events);
    }
  } catch (err) {
    console.error("pollEvents failed", err);
  }
}

setInterval(pollEvents, 12000000);

	// CHAIN BUILDER STATE AND HELPERS
	let chainAbilities = []; // from backend event
	let chain = [];
	let maxChainLength = 6;
	let executionAvailable = false;
	let executionRequested = false;

	function openChainBuilder() {
	  clearChoices();
	  document.body.classList.add("chain-active");
	  document.body.classList.add("chain-pulse-active");
	  const ov = document.getElementById("chain-overlay");
	  ov.classList.remove("hidden");
	  ov.setAttribute("aria-hidden", "false");
	  // Declare-chain UI should show RP (not Balance) while drafting.
	  try { clearBalance(); } catch (e) { /* ignore */ }
	  updateRPPanel();
	  executionRequested = false;
	  updateExecuteUI();
	}

	function closeChainBuilder() {
	  const ov = document.getElementById("chain-overlay");

  // 1. MOVE FOCUS FIRST
  const narration = document.getElementById("narration");
  if (narration) {
    narration.setAttribute("tabindex", "-1");
    narration.focus();
  } else {
    document.body.focus();
  }

  // 2. THEN hide visually + semantically
	  document.body.classList.remove("chain-active");
	  document.body.classList.remove("chain-pulse-active");
	  ov.classList.add("hidden");
	  ov.setAttribute("aria-hidden", "true");
	  clearRPPanel();
	  executionRequested = false;
	  updateExecuteUI();
	}

function updateExecuteUI() {
  const btn = document.getElementById("chain-execute");
  if (!btn) return;
  if (!executionAvailable) {
    btn.classList.add("hidden");
    btn.textContent = "EXECUTE";
    return;
  }
  btn.classList.remove("hidden");

  const rpCur = (typeof characterState?.rp === "object" && characterState?.rp) ? (characterState.rp.current ?? 0) : (characterState?.rp ?? 0);
  const hasRp = Number(rpCur) >= 1;
  const hasAttack = (chain || []).some(a => String(a?.type || "").toLowerCase() === "attack");
  btn.disabled = !(hasRp && hasAttack);

  if (!btn.disabled && executionRequested) {
    btn.textContent = "EXECUTE ✓";
    return;
  }
  if (btn.disabled) {
    executionRequested = false;
  }
  btn.textContent = executionRequested ? "EXECUTE ✓" : "EXECUTE";
}

	function toggleExecute() {
	  if (!executionAvailable) return;
	  executionRequested = !executionRequested;
	  updateExecuteUI();
	}


function clearChain() {
  chain = [];
  renderChain();
  updateExecuteUI();
}

function removeFromChain(i) {
  chain.splice(i, 1);
  renderChain();
  updateExecuteUI();
}

function addToChain(ability) {
  if (chain.length >= maxChainLength) return;
  chain.push(ability);
  renderChain();
  updateExecuteUI();
}

function abilityIsUsable(ab) {
  const cd = ab.cooldown ?? 0;
  return cd === 0 && !ab.disabled;
}

function renderAbilities(abilities) {
  const buckets = {
    attack: document.getElementById("attack-abilities"),
    defense: document.getElementById("defense-abilities"),
    utility: document.getElementById("utility-abilities"),
    movement: document.getElementById("movement-abilities"),
  };

  Object.values(buckets).forEach(el => el.innerHTML = "");

  abilities.forEach(ab => {
    const type = (ab.type || "").toLowerCase();
    const host = buckets[type];
    if (!host) return;

    const card = document.createElement("div");
    card.className = "ability-card";

    const usable = abilityIsUsable(ab);
    if (!usable) card.classList.add("disabled");

    const cost = (ab.cost ?? 0);
    const cd = (ab.cooldown ?? 0);

    card.innerHTML = `
      <div class="row">
        <div class="name">${ab.name}</div>
        <div class="meta">COST ${cost}${cd ? ` · CD ${cd}` : ""}</div>
      </div>
      ${ab.effect ? `<div class="desc">${ab.effect}</div>` : ""}
    `;

    if (usable) {
      card.onclick = () => addToChain(ab);
    }

    host.appendChild(card);
  });
}

function renderChain() {
 

  const slots = document.getElementById("chain-slots");
  slots.innerHTML = "";

  for (let i = 0; i < maxChainLength; i++) {
    const slot = document.createElement("div");
    slot.className = "chain-slot";

    if (chain[i]) {
      slot.classList.add("filled");
      slot.textContent = chain[i].name;
      slot.onclick = () => removeFromChain(i);
    } else {
      slot.textContent = "—";
    }

    slots.appendChild(slot);
  }

  const commit = document.getElementById("chain-commit");
  commit.disabled = false;
}

async function submitChain() {
  const ids = chain.map(a => a.id);

  closeChainBuilder();
  // Clear main output so the next chain resolution reads cleanly.
  clearNarration();
  log.innerHTML = "";
  await sendStep({
    action: "declare_chain",
    chain: ids,
    execute: executionRequested ? true : undefined
  });
}

function rejectChain(reasonText) {
  const ov = document.getElementById("chain-overlay");

  ov.classList.add("chain-reject");

  if (reasonText) {
    logCombat(reasonText, "system");
  }

  setTimeout(() => {
    ov.classList.remove("chain-reject");
  }, 400);
}

function renderChainRules(rules) {
  const sub = document.getElementById("chain-sub");
  const span = document.getElementById("chain-max");

  const min = rules?.min ?? 0;
  const max = rules?.max ?? maxChainLength;
  if (span) {
    span.textContent = String(max);
  }

  if (min === 0 && max) {
    sub.textContent = `Build a chain of up to ${max} links — or stand and endure.`;
  } else if (max && max > min) {
    sub.textContent = `Build a chain of ${min}–${max} links.`;
  } else if (max) {
    sub.textContent = `Build a chain of up to ${max} links.`;
  } else {
    sub.textContent = "Build your chain — or take the hit.";
  }

  if (rules?.source) {
    sub.textContent += ` (${rules.source})`;
  }
}

function renderChainHint(rules) {
  const hint = document.getElementById("chain-hint");

  if (rules?.min === 0) {
    hint.textContent = "Commit with an empty chain to brace and endure.";
  } else {
    hint.textContent = "Click a filled slot to remove it.";
  }
}

</script>

</body>

</html>
