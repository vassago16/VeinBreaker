<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>VEINBREAKER</title>

  <style>
    :root {
      --bg: #0b0d0f;
      --fg: #d6d6d6;
      --dim: #8a8a8a;
      --accent: #9e2b25;
      --line: #1e2226;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 14px;
    }

    header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      color: var(--dim);
      letter-spacing: 2px;
    }

    #log {
      padding: 16px;
      max-width: 900px;
      margin: 0 auto;
      min-height: 60vh;
    }

    .entry {
      margin-bottom: 12px;
      white-space: pre-wrap;
    }

    .scene {
      color: var(--dim);
    }

    .narration {
      color: var(--fg);
    }

    .loot {
      color: var(--accent);
    }

    .system {
      color: var(--dim);
      font-style: italic;
    }

footer {
  border-top: 1px solid var(--line);
  padding: 12px 16px;
  flex-shrink: 0;
  background: var(--bg);
}

    .combat-mode #narration-wrapper::after {
      background:
        radial-gradient(circle at 40% 30%, rgba(180, 0, 0, 0.25), transparent 60%),
        radial-gradient(circle at 60% 70%, rgba(120, 0, 0, 0.2), transparent 65%);
    }

    .choice {
      display: block;
      background: none;
      border: none;
      color: var(--fg);
      text-align: left;
      padding: 6px 0;
      cursor: pointer;
      font-family: inherit;
    }

    .choice:hover {
      color: var(--accent);
    }

    .prompt {
      color: var(--dim);
      margin-bottom: 8px;
    }

  #layout {
    display: flex;
    height: calc(100vh - 48px);
  }
/* ===== CHAIN OVERLAY ===== */
#chain-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  backdrop-filter: blur(3px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#chain-overlay.hidden {
  display: none;
}

.chain-active #narration-wrapper {
  opacity: 0.28;
  filter: blur(2px);
}

.chain-active #log,
.chain-active footer {
  opacity: 0.55;
}

.chain-modal {
  width: min(1100px, 92vw);
  max-height: 86vh;
  overflow: auto;
  background: #0d0d0d;
  border: 1px solid var(--accent);
  box-shadow: 0 0 0 1px rgba(158, 43, 37, 0.2);
  padding: 14px 14px 16px;
}

.chain-title {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--line);
  padding-bottom: 10px;
  margin-bottom: 12px;
}

.chain-h {
  letter-spacing: 3px;
  color: var(--fg);
  font-size: 12px;
}

.chain-sub {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
}

.chain-close {
  background: none;
  border: 1px solid var(--line);
  color: var(--dim);
  cursor: pointer;
  font-family: inherit;
  padding: 6px 10px;
}

.chain-close:hover {
  border-color: var(--accent);
  color: var(--fg);
}

.chain-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 12px;
}

.ability-column h3 {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--dim);
  margin: 0 0 8px;
}

.ability-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.ability-card {
  border: 1px solid var(--line);
  background: #101113;
  padding: 10px 10px 9px;
  cursor: pointer;
  transition: border-color 0.12s ease, transform 0.12s ease;
}

.ability-card:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.ability-card.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  transform: none;
}

.ability-card .row {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.ability-card .name {
  color: var(--fg);
  font-size: 13px;
}

.ability-card .meta {
  color: var(--dim);
  font-size: 12px;
}

.ability-card .desc {
  margin-top: 6px;
  color: var(--dim);
  font-size: 12px;
  line-height: 1.35;
}

.chain-preview {
  border-top: 1px solid var(--line);
  margin-top: 14px;
  padding-top: 12px;
}

#chain-slots {
  display: flex;
  gap: 10px;
  margin: 10px 0 12px;
  flex-wrap: wrap;
}

.chain-slot {
  width: 150px;
  height: 54px;
  border: 1px dashed var(--line);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: var(--dim);
}

.chain-slot.filled {
  border-style: solid;
  background: rgba(158, 43, 37, 0.12);
  color: var(--fg);
  cursor: pointer;
}

.chain-actions {
  display: flex;
  gap: 10px;
}

#chain-commit {
  border: 1px solid var(--accent);
  background: rgba(158, 43, 37, 0.15);
  color: var(--fg);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

#chain-commit:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.secondary {
  border: 1px solid var(--line);
  background: none;
  color: var(--dim);
  padding: 8px 12px;
  cursor: pointer;
  font-family: inherit;
}

.secondary:hover {
  border-color: var(--accent);
  color: var(--fg);
}

  .chain-hint {
    margin-top: 10px;
    color: var(--dim);
    font-size: 12px;
  }

  /* ===== ABILITIES PANEL ===== */

  #abilities-panel {
    margin-top: 16px;
    border-top: 1px solid var(--line);
    padding-top: 10px;
  }

  #abilities-panel .panel-title {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--dim);
    margin-bottom: 8px;
  }

  #abilities-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .ability-row {
    border: 1px solid var(--line);
    padding: 6px 8px;
    background: #101113;
    font-size: 12px;
  }

  .ability-row.cooldown {
    opacity: 0.45;
  }

  .ability-row .top {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }

  .ability-row .name {
    color: var(--fg);
  }

  .ability-row .meta {
    color: var(--dim);
    font-size: 11px;
  }

  .ability-row .tags {
    margin-top: 4px;
    font-size: 10px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

@keyframes chain-heartbeat {
  0% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
  35% {
    box-shadow:
      0 0 16px 4px rgba(158, 43, 37, 0.35),
      inset 0 0 10px 2px rgba(158, 43, 37, 0.28);
  }
  70% {
    box-shadow:
      0 0 10px 3px rgba(158, 43, 37, 0.22),
      inset 0 0 6px 2px rgba(158, 43, 37, 0.18);
  }
  100% {
    box-shadow:
      0 0 0 0 rgba(158, 43, 37, 0.12),
      inset 0 0 0 0 rgba(158, 43, 37, 0.08);
  }
}

  .chain-pulse .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
  }
  /* Alternate trigger for visibility-based pulse */
  .chain-pulse-active .chain-modal {
    animation: chain-heartbeat 1.4s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.65);
  }
  /* Keep the pulse active whenever the overlay is visible, even if chain-pulse isn't toggled */
  #chain-overlay:not(.hidden) .chain-modal {
    animation: chain-heartbeat 1.8s ease-in-out infinite;
    border-color: rgba(158, 43, 37, 0.55);
  }

@keyframes chain-reject-shake {
  0%   { transform: translateX(0); }
  15%  { transform: translateX(-6px); }
  30%  { transform: translateX(6px); }
  45%  { transform: translateX(-4px); }
  60%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

@keyframes chain-reject-flash {
  0%   { background-color: rgba(180, 0, 0, 0.35); }
  100% { background-color: transparent; }
}

.chain-reject .chain-modal {
  animation: chain-reject-shake 0.35s ease;
}

.chain-reject::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(180, 0, 0, 0.25);
  animation: chain-reject-flash 0.25s ease-out;
  pointer-events: none;
  z-index: 1001;
}

  #character-panel {
    width: 180px;
    padding: 16px 12px;
    border-right: 1px solid var(--line);
      color: var(--dim);
    }

    .vein-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .vein-node {
      width: 64px;
      height: 64px;
      border: 1px solid var(--accent);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle, rgba(158, 43, 37, 0.15), transparent 70%);
    }

    .vein-node .label {
      font-size: 10px;
      letter-spacing: 1px;
      color: var(--dim);
    }

    .vein-node .value {
      font-size: 18px;
      color: var(--fg);
    }

    .stats {
      border-top: 1px solid var(--line);
      padding-top: 12px;
      font-size: 12px;
    }

  .stats div {
    display: flex;
    justify-content: space-between;
    margin: 4px 0;
  }

  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-width: 0;
  }

  #main-scroll {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 12px;
  }

  #combat-log-panel {
    width: 260px;
    border-left: 1px solid var(--line);
    padding: 12px;
    font-size: 12px;
    color: var(--dim);
    background: #0b0b0b;
    position: relative;
  }

  #combat-log-header {
    font-size: 11px;
    letter-spacing: 2px;
    color: var(--fg);
    margin-bottom: 8px;
    opacity: 0.8;
    display: flex;
    align-items: center;
    cursor: pointer;
  }

  #signal-dot {
    width: 8px;
    height: 8px;
    background: rgba(158, 43, 37, 0.9);
    border-radius: 50%;
    margin-left: 8px;
    animation: signal-pulse 1.6s ease-in-out infinite;
  }

  #signal-dot.hidden {
    display: none;
  }

  @keyframes signal-pulse {
    0% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
    50% { box-shadow: 0 0 8px rgba(158,43,37,0.6); }
    100% { box-shadow: 0 0 0 rgba(158,43,37,0.0); }
  }

  #combat-log {
    max-height: calc(100vh - 60px);
    overflow-y: auto;
    padding-right: 6px;
  }

  .log-entry {
    margin-bottom: 6px;
    line-height: 1.4;
  }

  .log-entry.attack { color: #c9c9c9; }
  .log-entry.damage { color: #e07070; }
  .log-entry.block  { color: #7fa6ff; }
  .log-entry.system { color: #888; }
  .log-entry.interrupt { color: #ff8484; }
  .log-entry.roll { color: #e07070; font-weight: 600; }

  #main-scroll::-webkit-scrollbar,
  #combat-log::-webkit-scrollbar {
    width: 6px;
  }

  #main-scroll::-webkit-scrollbar-track,
  #combat-log::-webkit-scrollbar-track {
    background: transparent;
  }

  #main-scroll::-webkit-scrollbar-thumb,
  #combat-log::-webkit-scrollbar-thumb {
    background-color: rgba(158, 43, 37, 0.35);
    border-radius: 6px;
  }

  #main-scroll::-webkit-scrollbar-thumb:hover,
  #combat-log::-webkit-scrollbar-thumb:hover {
    background-color: rgba(158, 43, 37, 0.6);
  }

  .signal-drawer {
    position: absolute;
    right: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: #0b0c0e;
    border-left: 1px solid var(--line);
    z-index: 20;
  }

  .signal-drawer.hidden {
    display: none;
  }

  .signal-drawer-header {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    display: flex;
    justify-content: space-between;
    letter-spacing: 2px;
    font-size: 11px;
    color: var(--fg);
  }

  .signal {
    padding: 8px;
    border-bottom: 1px solid var(--line);
    background: rgba(158, 43, 37, 0.12);
    color: var(--fg);
  }

  /* Interrupt flash */
  @keyframes interrupt-flash {
    0%   { background-color: rgba(180, 0, 0, 0.15); }
    50%  { background-color: rgba(180, 0, 0, 0.35); }
    100% { background-color: transparent; }
  }

  .interrupt-flash {
    animation: interrupt-flash 0.18s ease-out;
  }

  /* ===== Narration Container ===== */

    #narration-wrapper {
      position: relative;
      overflow: hidden;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }

    #narration {
      transition: opacity 0.4s ease, filter 0.4s ease;
    }

    /* ===== Fade / Smear States ===== */

    .fade-out {
      opacity: 0;
      filter: blur(6px) contrast(120%) saturate(120%);
    }

    .fade-in {
      opacity: 1;
      filter: blur(0);
    }

    /* ===== Vein Smear Overlay ===== */

    #narration-wrapper::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 30% 40%,
          rgba(140, 0, 0, 0.15),
          transparent 60%),
        radial-gradient(circle at 70% 60%,
          rgba(90, 0, 0, 0.12),
          transparent 65%);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .smear-active::after {
      opacity: 1;
    }
  </style>
</head>

<body>

  <header>
    VEINBREAKER
  </header>

<div id="layout">
  <aside id="character-panel">
    <div class="vein-column">
      <div class="vein-node" id="hp-node">
        <span class="label">HP</span>
        <span class="value" id="char-hp">–</span>
      </div>

      <div class="vein-node" id="rp-node">
        <span class="label">RP</span>
        <span class="value" id="char-rp">–</span>
      </div>

      <div class="vein-node" id="veinscore-node">
        <span class="label">VEIN</span>
        <span class="value" id="char-veinscore">–</span>
      </div>
    </div>

    <div class="stats">
      <div>POW <span id="stat-str">–</span></div>
      <div>AGI <span id="stat-dex">–</span></div>
      <div>MND <span id="stat-int">–</span></div>
      <div>SPR <span id="stat-wil">–</span></div>
    </div>

    <section id="abilities-panel">
      <div class="panel-title">ABILITIES</div>
      <div id="abilities-list"></div>
    </section>
  </aside>

  <main id="main">
    <div id="main-scroll">
      <div id="narration-wrapper">
        <div id="narration"></div>
      </div>
      <div id="log"></div>
    </div>

    <footer id="choices"></footer>
  </main>

  <aside id="combat-log-panel">
    <div id="combat-log-header" onclick="openSignals()">
      <span>COMBAT LOG</span>
      <span id="signal-dot" class="signal-dot hidden"></span>
    </div>
    <div id="signal-drawer" class="signal-drawer hidden">
      <div class="signal-drawer-header">
        SIGNALS
        <button onclick="closeSignals()">✕</button>
      </div>
      <div id="signal-list"></div>
    </div>
    <div id="combat-log"></div>
  </aside>
</div>

<!-- CHAIN OVERLAY (hidden until declare_chain event) -->
<div id="chain-overlay" class="hidden" aria-hidden="true">
  <div class="chain-modal">
    <div class="chain-title">
      <div class="chain-title-left">
        <div class="chain-h">DECLARE CHAIN</div>
        <div class="chain-sub" id="chain-sub">Select up to <span id="chain-max">6</span> links.</div>
      </div>
      <button class="chain-close" onclick="closeChainBuilder()">X</button>
    </div>

    <div class="chain-columns">
      <div class="ability-column">
        <h3>ATTACK</h3>
        <div id="attack-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>DEFENSE</h3>
        <div id="defense-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>UTILITY</h3>
        <div id="utility-abilities" class="ability-list"></div>
      </div>

      <div class="ability-column">
        <h3>MOVEMENT</h3>
        <div id="movement-abilities" class="ability-list"></div>
      </div>
    </div>

    <div class="chain-preview">
      <h3>CHAIN</h3>
      <div id="chain-slots"></div>

      <div class="chain-actions">
        <button id="chain-commit" onclick="submitChain()">COMMIT CHAIN</button>
        <button class="secondary" onclick="clearChain()">CLEAR</button>
      </div>

      <div class="chain-hint" id="chain-hint">Tip: click a filled slot to remove it.</div>
    </div>
  </div>
</div>

  <script>
const API = "http://localhost:8000/step"; // adjust if needed
const EVENTS_API = "http://localhost:8000/events";
const CHARACTER_API = "http://localhost:8000/character";
const sessionId = crypto.randomUUID();
document.body.classList.add("chain-pulse");

const log = document.getElementById("log");
const combatLog = document.getElementById("combat-log");
const signalDot = document.getElementById("signal-dot");
const narrationWrapper = document.getElementById("narration-wrapper");
const narrationEl = document.getElementById("narration");
const choicesEl = document.getElementById("choices");
const charHp = document.getElementById("char-hp");
const charRp = document.getElementById("char-rp");
    const charVeinscore = document.getElementById("char-veinscore");
    const statStr = document.getElementById("stat-str");
const statDex = document.getElementById("stat-dex");
const statInt = document.getElementById("stat-int");
const statWil = document.getElementById("stat-wil");
let signals = [];
let hasUnreadSignals = false;

function addEntry(text, cls) {
  const div = document.createElement("div");
  div.className = `entry ${cls}`;
  div.textContent = text;
  log.appendChild(div);
  window.scrollTo(0, document.body.scrollHeight);
}

function clearChoices() {
  choicesEl.innerHTML = "";
}

async function sendStep(payload) {
  const res = await fetch(API, {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({ session_id: sessionId, ...payload })
  });

  const events = await res.json();
  handleEvents(events);
}

async function sendChoice(index) {
  clearChoices();
  await sendStep({ choice: index });
}

function clearNarration() {
  narrationEl.classList.add("fade-out");
  narrationWrapper.classList.add("smear-active");

  setTimeout(() => {
    narrationEl.innerHTML = "";
    narrationEl.classList.remove("fade-out");
    narrationEl.classList.add("fade-in");
    narrationWrapper.classList.remove("smear-active");
    setTimeout(() => narrationEl.classList.remove("fade-in"), 400);
  }, 400);
}

function appendNarration(text) {
  const p = document.createElement("p");
  p.textContent = text;
  p.style.opacity = "0";
  p.style.transition = "opacity 0.3s ease";
  narrationEl.appendChild(p);
  requestAnimationFrame(() => {
    p.style.opacity = "1";
  });
  window.scrollTo(0, document.body.scrollHeight);
}

function appendCombatLog(text) {
  logCombat(text);
}

function logCombat(text, type = "system") {
  const div = document.createElement("div");
  div.className = `log-entry ${type}`;
  div.textContent = text;
  combatLog.prepend(div);
  combatLog.scrollTop = 0;
}

function addSignal(type, text) {
  signals.unshift({ type, text });
  hasUnreadSignals = true;
  signalDot.classList.remove("hidden");
  renderSignals();
}

function renderSignals() {
  const host = document.getElementById("signal-list");
  host.innerHTML = "";

  signals.forEach(s => {
    const div = document.createElement("div");
    div.className = "signal";
    div.innerHTML = `<strong>${(s.type || "SYSTEM").toUpperCase()}</strong><br>${s.text}`;
    host.appendChild(div);
  });
}

function openSignals() {
  document.getElementById("signal-drawer").classList.remove("hidden");
  hasUnreadSignals = false;
  signalDot.classList.add("hidden");
}

function closeSignals() {
  document.getElementById("signal-drawer").classList.add("hidden");
}

function setCombatActive(active) {
  // panel is always present; no-op placeholder for future state toggles
}

function flashInterrupt() {
  triggerInterruptFlash();
}

function triggerInterruptFlash() {
  document.body.classList.add("interrupt-flash");
  setTimeout(() => {
    document.body.classList.remove("interrupt-flash");
  }, 180);
}

function updateCharacterUI(char) {
  if (!char) return;
  if (char.hp) {
    const cur = char.hp.current ?? char.hp;
    const max = char.hp.max ?? char.hp_max ?? cur;
    charHp.textContent = `${cur}/${max}`;
  }
  if (char.rp !== undefined) {
    charRp.textContent = char.rp;
  }
  if (char.veinscore !== undefined) {
    charVeinscore.textContent = char.veinscore;
  }
  if (char.attributes) {
    statStr.textContent = char.attributes.str ?? "–";
    statDex.textContent = char.attributes.dex ?? "–";
    statInt.textContent = char.attributes.int ?? "–";
    statWil.textContent = char.attributes.wil ?? "–";
  }
  renderAbilitiesPanel(char);
}

function renderAbilitiesPanel(character) {
  const host = document.getElementById("abilities-list");
  host.innerHTML = "";

  if (!character?.abilities) return;

  character.abilities.forEach(ab => {
    const row = document.createElement("div");
    row.className = "ability-row";

    if (ab.cooldown && ab.cooldown > 0) {
      row.classList.add("cooldown");
    }

    const tags = (ab.tags || []).join(" · ");

    row.innerHTML = `
      <div class="top">
        <div class="name">${ab.name}</div>
        <div class="meta">
          ${ab.cost ? `${ab.cost} RP` : ""}
          ${ab.cooldown ? ` · CD ${ab.cooldown}` : ""}
        </div>
      </div>
      <div class="tags">
        ${ab.tier ? `T${ab.tier} · ` : ""}${tags}
      </div>
    `;

    host.appendChild(row);
  });
}

function renderChoices(prompt, options) {
  clearChoices();

  const p = document.createElement("div");
  p.className = "prompt";
  p.textContent = prompt;
  choicesEl.appendChild(p);

  options.forEach((opt, i) => {
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = `${i + 1}. ${opt}`;
    btn.onclick = () => sendChoice(i);
    choicesEl.appendChild(btn);
  });
}

function handleEvents(events) {
  events.forEach(ev => {
    switch (ev.type) {
      case "clear":
        if (ev.target === "narration" || ev.target === "all") {
          clearNarration();
        }
        if (ev.target === "choices" || ev.target === "all") {
          clearChoices();
        }
        if (ev.target === "log" || ev.target === "all") {
          log.innerHTML = "";
        }
        break;
      case "scene":
        appendNarration(ev.text);
        break;
      case "narration":
        appendNarration(ev.text);
        break;
      case "character_update":
        updateCharacterUI(ev.character);
        break;
      case "loot":
        addEntry(ev.text, "loot");
        break;
      case "system":
        addEntry(ev.text, "system");
        break;
      case "log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_log":
        logCombat(ev.text, ev.logType || "system");
        break;
      case "combat_state":
        setCombatActive(!!ev.active);
        break;
      case "interrupt":
        flashInterrupt();
        if (ev.text) {
          logCombat(ev.text, "interrupt");
        }
        break;
      case "declare_chain":
        chainAbilities = ev.abilities || [];
        maxChainLength = Math.max(ev.maxLength ?? 6, 6);
        const maxEl = document.getElementById("chain-max");
        if (maxEl) {
          maxEl.textContent = String(maxChainLength);
        }
        chain = [];
        renderAbilities(chainAbilities);
        renderChain();
        renderChainRules(ev.chainRules);
        renderChainHint(ev.chainRules);
        openChainBuilder();
        break;
      case "signal":
        addSignal(ev.signalType || "system", ev.text);
        break;
      case "chain_rejected":
        rejectChain(ev.reason);
        break;
      case "choice":
        renderChoices(ev.prompt, ev.options);
        break;
    }
  });
}

// initial kick
fetch(API, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    session_id: sessionId,
    action: "start"
  })
})
  .then(res => res.json())
  .then(handleEvents);

fetch(CHARACTER_API)
  .then(res => res.json())
  .then(updateCharacterUI);

async function pollEvents() {
  try {
    const res = await fetch(EVENTS_API, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ session_id: sessionId })
    });

    const events = await res.json();
    if (Array.isArray(events) && events.length) {
      handleEvents(events);
    }
  } catch (err) {
    console.error("pollEvents failed", err);
  }
}

setInterval(pollEvents, 12000000);

// CHAIN BUILDER STATE AND HELPERS
let chainAbilities = []; // from backend event
let chain = [];
let maxChainLength = 6;

function openChainBuilder() {
  clearChoices();
  document.body.classList.add("chain-active");
  document.body.classList.add("chain-pulse-active");
  const ov = document.getElementById("chain-overlay");
  ov.classList.remove("hidden");
  ov.setAttribute("aria-hidden", "false");
}

function closeChainBuilder() {
  const ov = document.getElementById("chain-overlay");

  // 1. MOVE FOCUS FIRST
  const narration = document.getElementById("narration");
  if (narration) {
    narration.setAttribute("tabindex", "-1");
    narration.focus();
  } else {
    document.body.focus();
  }

  // 2. THEN hide visually + semantically
  document.body.classList.remove("chain-active");
  document.body.classList.remove("chain-pulse-active");
  ov.classList.add("hidden");
  ov.setAttribute("aria-hidden", "true");
}


function clearChain() {
  chain = [];
  renderChain();
}

function removeFromChain(i) {
  chain.splice(i, 1);
  renderChain();
}

function addToChain(ability) {
  if (chain.length >= maxChainLength) return;
  chain.push(ability);
  renderChain();
}

function abilityIsUsable(ab) {
  const cd = ab.cooldown ?? 0;
  return cd === 0 && !ab.disabled;
}

function renderAbilities(abilities) {
  const buckets = {
    attack: document.getElementById("attack-abilities"),
    defense: document.getElementById("defense-abilities"),
    utility: document.getElementById("utility-abilities"),
    movement: document.getElementById("movement-abilities"),
  };

  Object.values(buckets).forEach(el => el.innerHTML = "");

  abilities.forEach(ab => {
    const type = (ab.type || "").toLowerCase();
    const host = buckets[type];
    if (!host) return;

    const card = document.createElement("div");
    card.className = "ability-card";

    const usable = abilityIsUsable(ab);
    if (!usable) card.classList.add("disabled");

    const cost = (ab.cost ?? 0);
    const cd = (ab.cooldown ?? 0);

    card.innerHTML = `
      <div class="row">
        <div class="name">${ab.name}</div>
        <div class="meta">COST ${cost}${cd ? ` · CD ${cd}` : ""}</div>
      </div>
      ${ab.effect ? `<div class="desc">${ab.effect}</div>` : ""}
    `;

    if (usable) {
      card.onclick = () => addToChain(ab);
    }

    host.appendChild(card);
  });
}

function renderChain() {
 

  const slots = document.getElementById("chain-slots");
  slots.innerHTML = "";

  for (let i = 0; i < maxChainLength; i++) {
    const slot = document.createElement("div");
    slot.className = "chain-slot";

    if (chain[i]) {
      slot.classList.add("filled");
      slot.textContent = chain[i].name;
      slot.onclick = () => removeFromChain(i);
    } else {
      slot.textContent = "—";
    }

    slots.appendChild(slot);
  }

  const commit = document.getElementById("chain-commit");
  commit.disabled = false;
}

async function submitChain() {
  const ids = chain.map(a => a.id);

  closeChainBuilder();
  await sendStep({
    action: "declare_chain",
    chain: ids
  });
}

function rejectChain(reasonText) {
  const ov = document.getElementById("chain-overlay");

  ov.classList.add("chain-reject");

  if (reasonText) {
    logCombat(reasonText, "system");
  }

  setTimeout(() => {
    ov.classList.remove("chain-reject");
  }, 400);
}

function renderChainRules(rules) {
  const sub = document.getElementById("chain-sub");
  const span = document.getElementById("chain-max");

  const min = rules?.min ?? 0;
  const max = rules?.max ?? maxChainLength;
  if (span) {
    span.textContent = String(max);
  }

  if (min === 0 && max) {
    sub.textContent = `Build a chain of up to ${max} links — or stand and endure.`;
  } else if (max && max > min) {
    sub.textContent = `Build a chain of ${min}–${max} links.`;
  } else if (max) {
    sub.textContent = `Build a chain of up to ${max} links.`;
  } else {
    sub.textContent = "Build your chain — or take the hit.";
  }

  if (rules?.source) {
    sub.textContent += ` (${rules.source})`;
  }
}

function renderChainHint(rules) {
  const hint = document.getElementById("chain-hint");

  if (rules?.min === 0) {
    hint.textContent = "Commit with an empty chain to brace and endure.";
  } else {
    hint.textContent = "Click a filled slot to remove it.";
  }
}

  </script>

</body>

</html>
